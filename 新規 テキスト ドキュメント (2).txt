äº†è§£ã§ã™ ğŸ‘
ä»¥ä¸‹ã¯ `.NET 8` å‘ã‘ã®å®Œå…¨ãª `SnapshotWorker` ã‚¯ãƒ©ã‚¹ã®æœ€æ–°ç‰ˆã§ã™ã€‚
ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ï¼š

* æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ `var pattern = "*.zip";` ã®ã‚ˆã†ã«å¤‰æ›´å¯èƒ½
* éåŒæœŸ (`await Parallel.ForEachAsync`) ã§ä¸¦åˆ—ãƒãƒƒã‚·ãƒ¥è¨ˆç®—
* `FileName`ï¼ˆï¼`fi.Name`ï¼‰ã‚’ã‚­ãƒ¼ã«ã—ãŸ `ImmutableDictionary` ã‚’æ§‹ç¯‰
* è¾æ›¸ã®è¡çªæ™‚ã¯æ›´æ–°æ—¥æ™‚ãŒæ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å„ªå…ˆ
* `Task.Run` ã¯ä¸€åˆ‡ä½¿ã£ã¦ã„ã¾ã›ã‚“

---

```csharp
using System.Collections.Immutable;
using System.IO.Compression;
using System.Security.Cryptography;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public sealed record ArchiveInfo(
    string ArchiveName,     // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åï¼ˆã‚­ãƒ¼ï¼‰
    string FilePath,        // å®Ÿãƒ‘ã‚¹
    long Size,
    DateTimeOffset ModifiedUtc,
    byte[] Hash
);

public interface IFileIndex
{
    ImmutableDictionary<string, ArchiveInfo> Snapshot { get; }
    void Replace(ImmutableDictionary<string, ArchiveInfo> next);
}

public sealed class InMemoryFileIndex : IFileIndex
{
    private ImmutableDictionary<string, ArchiveInfo> _snap =
        ImmutableDictionary<string, ArchiveInfo>.Empty.WithComparers(StringComparer.OrdinalIgnoreCase);

    public ImmutableDictionary<string, ArchiveInfo> Snapshot =>
        System.Threading.Volatile.Read(ref _snap);

    public void Replace(ImmutableDictionary<string, ArchiveInfo> next) =>
        System.Threading.Interlocked.Exchange(ref _snap, next);
}

/// <summary>
/// æŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€å†…ã®ZIPï¼ˆãªã©ï¼‰ã‚’å®šæœŸã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’æ›´æ–°ã™ã‚‹
/// </summary>
public sealed class SnapshotWorker : BackgroundService
{
    private readonly ILogger<SnapshotWorker> _log;
    private readonly IFileIndex _index;

    private readonly string _folder = @"D:\data";           // ç›£è¦–ãƒ•ã‚©ãƒ«ãƒ€
    private readonly string _pattern = "*.zip";             // å¯¾è±¡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: "*.zipself" ç­‰ï¼‰
    private readonly bool _recurse = false;                 // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€å†å¸°æ¢ç´¢ã™ã‚‹ã‹
    private readonly TimeSpan _period = TimeSpan.FromSeconds(30);

    public SnapshotWorker(ILogger<SnapshotWorker> log, IFileIndex index)
    {
        _log = log;
        _index = index;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // åˆå›ã‚¹ã‚­ãƒ£ãƒ³
        await BuildAndSwapAsync(stoppingToken);

        using var timer = new PeriodicTimer(_period);
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            try
            {
                await BuildAndSwapAsync(stoppingToken);
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _log.LogWarning(ex, "Snapshot update failed");
            }
        }
    }

    /// <summary>
    /// å¯¾è±¡ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’å†æ§‹ç¯‰ã™ã‚‹
    /// </summary>
    private async Task BuildAndSwapAsync(CancellationToken ct)
    {
        var option = _recurse ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
        var files = Directory.EnumerateFiles(_folder, _pattern, option);

        var bag = new System.Collections.Concurrent.ConcurrentBag<ArchiveInfo>();

        await Parallel.ForEachAsync(files, new ParallelOptions
        {
            CancellationToken = ct,
            MaxDegreeOfParallelism = Environment.ProcessorCount
        },
        async (path, token) =>
        {
            try
            {
                var fi = new FileInfo(path);
                if (!fi.Exists) return;

                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦ãƒãƒƒã‚·ãƒ¥è¨ˆç®—
                await using var fs = new FileStream(
                    path, FileMode.Open, FileAccess.Read,
                    FileShare.ReadWrite | FileShare.Delete,
                    bufferSize: 1024 * 64,
                    options: FileOptions.Asynchronous | FileOptions.SequentialScan);

                var hash = await SHA256.HashDataAsync(fs, token);

                bag.Add(new ArchiveInfo(
                    ArchiveName: fi.Name,
                    FilePath: fi.FullName,
                    Size: fi.Length,
                    ModifiedUtc: fi.LastWriteTimeUtc,
                    Hash: hash
                ));
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch
            {
                // èª­ã¿è¾¼ã¿ä¸­ãªã©ã§é–‹ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
            }
        });

        // ä¸€æ„ã‚­ãƒ¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã§è¾æ›¸ã‚’æ§‹ç¯‰ã€‚é‡è¤‡ã¯æ–°ã—ã„æ–¹ã‚’å„ªå…ˆã€‚
        var builder = ImmutableDictionary.CreateBuilder<string, ArchiveInfo>(StringComparer.OrdinalIgnoreCase);

        foreach (var info in bag)
        {
            if (!builder.TryGetValue(info.ArchiveName, out var existing))
            {
                builder[info.ArchiveName] = info;
            }
            else if (info.ModifiedUtc > existing.ModifiedUtc)
            {
                builder[info.ArchiveName] = info;
            }
        }

        // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’åŸå­çš„ã«å…¥ã‚Œæ›¿ãˆ
        _index.Replace(builder.ToImmutable());

        _log.LogInformation("Snapshot updated: {Count} archives indexed", builder.Count);
    }
}
```

---

## ğŸ’¡ãƒã‚¤ãƒ³ãƒˆ

* `_pattern` ã‚’ `"*.zip"`, `"*.zipself"`, `"*.7z"` ãªã©ã«å¤‰ãˆã‚‹ã ã‘ã§å¯¾å¿œå¯èƒ½ã€‚
  â†’ `Directory.EnumerateFiles(_folder, _pattern, option)` ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã§æ¤œç´¢ã—ã¾ã™ã€‚
* `Task.Run()` ã‚’ä½¿ã‚ãšã« `Parallel.ForEachAsync()` ã‚’åˆ©ç”¨ã€‚
  ã“ã‚Œã¯ .NET 6+ ã®ãƒã‚¤ãƒ†ã‚£ãƒ–éåŒæœŸç‰ˆã§ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ç®¡ç†ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚
* `FileInfo.Name` ã‚’ã‚­ãƒ¼ã«ã—ã¦ã„ã‚‹ã®ã§ã€ã‚µãƒ¼ãƒï¼ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé–“ã§ç•°ãªã‚‹ãƒ‘ã‚¹æ§‹æˆã§ã‚‚å•é¡Œãªã—ã€‚
* ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ­ãƒƒã‚¯ä¸­ã§ã‚‚ä¾‹å¤–ã§æ­¢ã¾ã‚‰ãªã„ã‚ˆã†ã«å®‰å…¨ã«æ¡ã£ã¦ã„ã¾ã™ã€‚

---

ã“ã® `SnapshotWorker` ã‚’ `Program.cs` ã§ç™»éŒ²ã—ã¦ãŠã‘ã°ã€
30ç§’ã”ã¨ã« ZIP ãƒ•ã‚¡ã‚¤ãƒ«ç¾¤ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã™ã€‚


çµè«–ï¼š**å°‘ã—ã ã‘è¦ä¿®æ­£**ã§ã™ã€‚
ã„ã¾ã® `ProcessService` ã¯ `FilePath` ã‚’ã‚­ãƒ¼ã«ã—ã¦å·®åˆ†ã‚’å–ã£ã¦ã„ã¾ã™ãŒã€å…ˆã«æ±ºã‚ãŸã€Œ**ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åï¼ˆ`ArchiveName`ï¼`fi.Name`ï¼‰ã§ä¸€æ„**ã€æ–¹é‡ã«åˆã‚ã›ã¦ã€ä»¥ä¸‹ã‚’ç›´ã™ã¨æ•´åˆãŒå–ã‚Œã¾ã™ã€‚

# å¤‰ãˆã‚‹ãƒã‚¤ãƒ³ãƒˆ

1. å·®åˆ†ã‚­ãƒ¼ã‚’ `FilePath` â†’ **`ArchiveName`** ã«å¤‰æ›´
2. ZIP ä½œæˆã¯ **ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å â†’ ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å®Ÿãƒ‘ã‚¹ã«è§£æ±º** ã—ã¦è©°ã‚ã‚‹
3. `Channel` ã®èª­å–ã¯ `WaitToReadAsync` + `TryRead` ã‚ˆã‚Š **`await foreach (_reader.ReadAllAsync(ct))`** ãŒç°¡æ½”
4. `JsonSerializerOptions` ã¯æ¯å› new ã›ãš **static** ã«

# ä¿®æ­£ç‰ˆ `ProcessService`ï¼ˆ.NET 8ï¼‰

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Immutable;
using System.IO.Compression;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Channels;
using System.Globalization;

public sealed class ProcessService : BackgroundService
{
    private readonly ILogger<ProcessService> _log;
    private readonly ChannelReader<SyncJob> _reader;
    private readonly IFileIndex _index;
    private readonly string _bundleDir = Path.Combine(Path.GetTempPath(), "sync-bundles");
    private readonly int _workers = Math.Max(1, Environment.ProcessorCount / 2);

    private static readonly JsonSerializerOptions JsonOpt = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };

    public ProcessService(ILogger<ProcessService> log, ChannelReader<SyncJob> reader, IFileIndex index)
    {
        _log = log; _reader = reader; _index = index;
        Directory.CreateDirectory(_bundleDir);
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var tasks = Enumerable.Range(0, _workers)
            .Select(i => WorkerLoopAsync(i, stoppingToken)).ToArray();

        await Task.WhenAll(tasks);
    }

    private async Task WorkerLoopAsync(int id, CancellationToken ct)
    {
        _log.LogInformation("Worker {Id} started", id);

        try
        {
            await foreach (var job in _reader.ReadAllAsync(ct))
            {
                try
                {
                    var req = JsonSerializer.Deserialize<ClientSyncRequest>(job.Json, JsonOpt) ?? new();

                    // å·®åˆ†ã¯ â€œã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ€ ã§çªãåˆã‚ã›ã‚‹
                    var diff = ComputeDiffByName(_index.Snapshot, req);

                    // å¿…è¦ãªã‚‰ ZIP ãƒãƒ³ãƒ‰ãƒ«ã‚’ä½œã‚‹ï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ†’å®Ÿãƒ‘ã‚¹ã«è§£æ±ºï¼‰
                    string? zipPath = null;
                    if (req.BundleMissingAsZip && diff.ToDownload.Count > 0)
                        zipPath = await CreateBundleByNameAsync(diff.ToDownload, _index.Snapshot, ct);

                    job.Tcs.TrySetResult(new ServerSyncResult
                    {
                        ToDownload = diff.ToDownload,
                        ToDelete   = diff.ToDelete,
                        UpToDate   = diff.UpToDate,
                        ZipPath    = zipPath
                    });
                }
                catch (OperationCanceledException) { throw; }
                catch (Exception ex)
                {
                    job.Tcs.TrySetResult(new ServerSyncResult { Error = "processing_failed" });
                    _log.LogWarning(ex, "Worker {Id} failed", id);
                }
            }
        }
        catch (OperationCanceledException) { /* stopping */ }
        _log.LogInformation("Worker {Id} stopped", id);
    }

    // ---- å·®åˆ†ï¼ˆã‚­ãƒ¼ï¼ArchiveNameï¼‰----
    private static (List<string> ToDownload, List<string> ToDelete, List<string> UpToDate)
        ComputeDiffByName(ImmutableDictionary<string, ArchiveInfo> server, ClientSyncRequest req)
    {
        // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚‚ ArchiveName ã‚’é€ã£ã¦ãã‚‹å‰æ
        var cli = (req.Files ?? new()).ToDictionary(x => x.ArchiveName, x => x, StringComparer.OrdinalIgnoreCase);

        var toDownload = new List<string>();
        var toDelete   = new List<string>();
        var upToDate   = new List<string>();

        foreach (var (name, s) in server)
        {
            if (!cli.TryGetValue(name, out var c))
                toDownload.Add(name);
            else if (!HashesEqual(s.Hash, c.Sha256Hex))
                toDownload.Add(name);
            else
                upToDate.Add(name);
        }
        foreach (var (name, _) in cli)
            if (!server.ContainsKey(name))
                toDelete.Add(name);

        return (toDownload, toDelete, upToDate);
    }

    // ---- ZIPä½œæˆï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ†’å®Ÿãƒ‘ã‚¹ã«è§£æ±ºï¼‰----
    private async Task<string> CreateBundleByNameAsync(
        List<string> archiveNames,
        ImmutableDictionary<string, ArchiveInfo> snap,
        CancellationToken ct)
    {
        var name = $"bundle_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmssfff}.zip";
        var zip  = Path.Combine(_bundleDir, name);

        using var fs = new FileStream(zip, FileMode.Create, FileAccess.Write, FileShare.None);
        using var za = new ZipArchive(fs, ZipArchiveMode.Create, leaveOpen: false);

        foreach (var an in archiveNames)
        {
            ct.ThrowIfCancellationRequested();
            if (!snap.TryGetValue(an, out var info)) continue; // å¿µã®ãŸã‚å­˜åœ¨ç¢ºèª

            var entry = za.CreateEntry(an, CompressionLevel.Fastest); // å¤§é‡é…å¸ƒãªã‚‰ Fastest ã®ã»ã†ãŒç·åˆçš„ã«é€Ÿã„
            using var es  = entry.Open();
            using var src = new FileStream(info.FilePath, FileMode.Open, FileAccess.Read,
                                           FileShare.ReadWrite | FileShare.Delete);
            await src.CopyToAsync(es, ct);
        }
        return zip;
    }

    // ---- ãƒãƒƒã‚·ãƒ¥æ¯”è¼ƒï¼ˆSpanæœ€é©åŒ–ç‰ˆã§ã‚‚OKï¼‰----
    private static bool HashesEqual(byte[] serverHash, string? clientHex)
    {
        if (string.IsNullOrWhiteSpace(clientHex) || clientHex.Length != 64)
            return false;

        Span<byte> buf = stackalloc byte[32];
        for (int i = 0; i < 32; i++)
        {
            // ä½GCã«ã—ãŸã„ãªã‚‰ byte.Parse(span, NumberStyles.HexNumber, CultureInfo.InvariantCulture)
            string hexByte = clientHex.Substring(i * 2, 2);
            buf[i] = Convert.ToByte(hexByte, 16);
        }
        return serverHash.AsSpan().SequenceEqual(buf);
    }
}
```

## ä½µã›ã¦ç›´ã™ã¹ã DTOï¼ˆé‡è¦ï¼‰

* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ/ã‚µãƒ¼ãƒé–“ã§ã®ç…§åˆã‚­ãƒ¼ã‚’ **`ArchiveName`** ã«çµ±ä¸€ã—ã¦ãã ã•ã„ã€‚

```csharp
public sealed class ClientSyncRequest
{
    public List<ClientFileInfo>? Files { get; set; }
    public bool BundleMissingAsZip { get; set; } = true;
}

public sealed class ClientFileInfo
{
    public string ArchiveName { get; set; } = "";   // â† ã“ã“ã‚’ FilePath ã‹ã‚‰å¤‰æ›´
    public long Size { get; set; }
    public DateTimeOffset ModifiedUtc { get; set; }
    public string? Sha256Hex { get; set; }
}

public sealed class ServerSyncResult
{
    public List<string> ToDownload { get; set; } = new(); // â† ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åã®é…åˆ—
    public List<string> ToDelete   { get; set; } = new();
    public List<string> UpToDate   { get; set; } = new();
    public string? ZipPath { get; set; }
    public string? Error { get; set; }
}
```

> ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå´ï¼ˆ`ArchiveInfo`ï¼‰ã¯ `ArchiveName` ã¨ `FilePath` ã®ä¸¡æ–¹ã‚’æŒãŸã›ã¦OKã§ã™ï¼ˆåå¯„ã›ã‚­ãƒ¼ï¼‹å®Ÿãƒ‘ã‚¹è§£æ±ºç”¨ï¼‰ã€‚

---

ã“ã‚Œã§ã€Œ**åå‰ä¸€æ„**ã€ã®å‰æã«æ²¿ã£ã¦ã€

* å·®åˆ†ã¯**åå‰**ã§å³å¯†ã«åˆ¤å®š
* ZIP è©°ã‚ã¯**ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã§å®Ÿãƒ‘ã‚¹ã«è§£æ±º**
* Channel ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã¯**ã‚·ãƒ³ãƒ—ãƒ«ãª ReadAllAsync**

â€¦ã¨ã„ã†å½¢ã«æ•´ç†ã§ãã¾ã™ã€‚

ã„ã„è³ªå•ã§ã™ã€‚
ã‚ãªãŸãŒç¤ºã—ã¦ã„ã‚‹éƒ¨åˆ†ï¼ˆ`ComputeDiffByName` ã‚„ `HashesEqual` ã‚’å«ã‚€å‡¦ç†ï¼‰ã¯ã€
**ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã¨ã‚µãƒ¼ãƒå´ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆï¼åœ§ç¸®ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã®å·®åˆ†ã‚’åˆ¤å®šã€**ã—ã¦ã„ã¾ã™ã€‚

---

### ğŸ” ç›®çš„

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã€Œè‡ªåˆ†ã®æŒã£ã¦ã„ã‚‹ ZIP ç¾¤ã®æƒ…å ±ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãƒ»ãƒãƒƒã‚·ãƒ¥ãªã©ï¼‰ã€ã‚’ã‚µãƒ¼ãƒã«é€ã‚Šã¾ã™ã€‚
ã‚µãƒ¼ãƒã¯è‡ªåˆ†ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆï¼ç›£è¦–ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ZIPä¸€è¦§ï¼‰ã¨ç…§ã‚‰ã—åˆã‚ã›ã¦ã€
æ¬¡ã®3ã¤ã«åˆ†é¡ã—ã¾ã™ï¼š

| åˆ¤å®šçµæœ           | æ„å‘³                             | ä¾‹                   |
| -------------- | ------------------------------ | ------------------- |
| **ToDownload** | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ç„¡ã„ï¼ãƒãƒƒã‚·ãƒ¥ãŒç•°ãªã‚‹ â‡’ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ | ã‚µãƒ¼ãƒã®`a.zip`ãŒæ›´æ–°ã•ã‚Œã¦ã„ãŸ |
| **ToDelete**   | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚ã£ã¦ã‚µãƒ¼ãƒã«ç„¡ã„ â‡’ å‰Šé™¤ã™ã¹ã       | ã‚µãƒ¼ãƒã§ã¯`old.zip`ãŒå‰Šé™¤æ¸ˆã¿ |
| **UpToDate**   | ä¸¡è€…ã®ãƒãƒƒã‚·ãƒ¥ä¸€è‡´ â‡’ åŒä¸€å†…å®¹               | `config.zip`ãŒåŒã˜çŠ¶æ…‹   |

---

### âš™ï¸ å…·ä½“çš„ãªæµã‚Œ

```csharp
var diff = ComputeDiffByName(_index.Snapshot, req);
```

1. `_index.Snapshot`
   â†’ ã‚µãƒ¼ãƒä¸Šã®ã€Œæœ€æ–°ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã€ï¼ˆã™ã¹ã¦ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ï¼šåå‰ãƒ»ã‚µã‚¤ã‚ºãƒ»SHA256ãƒãƒƒã‚·ãƒ¥ï¼‰

2. `req`
   â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰é€ã‚‰ã‚ŒãŸã€Œè‡ªåˆ†ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã€ï¼ˆåŒã˜å½¢å¼ï¼‰

3. `ComputeDiffByName(...)`
   â†’ ä¸¡è€…ã‚’åå‰ï¼ˆ`ArchiveName`ï¼‰ã§çªãåˆã‚ã›ã¦

   * ã‚µãƒ¼ãƒã«ã ã‘ã‚ã‚‹ â†’ `ToDownload`
   * ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã ã‘ã‚ã‚‹ â†’ `ToDelete`
   * ä¸¡æ–¹ã‚ã‚Šãƒãƒƒã‚·ãƒ¥ä¸€è‡´ â†’ `UpToDate`

---

### ğŸ’¡ `HashesEqual` ã®å½¹å‰²

```csharp
private static bool HashesEqual(byte[] serverHash, string? clientHex)
```

ã“ã‚Œã¯ã€Œã‚µãƒ¼ãƒã®SHA256ï¼ˆãƒã‚¤ãƒˆé…åˆ—ï¼‰ã€ã¨ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒé€ã£ãŸSHA256ï¼ˆ16é€²æ–‡å­—åˆ—ï¼‰ã€ã‚’æ¯”è¼ƒã™ã‚‹é–¢æ•°ã§ã™ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯è‡ªåˆ†ã®ZIPã®å†…å®¹ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã€
ã‚µãƒ¼ãƒã« `"Sha256Hex": "ABCDEF..."` ã®ã‚ˆã†ã«é€ã‚Šã¾ã™ã€‚
ã‚µãƒ¼ãƒã¯è‡ªåˆ†ã§è¨ˆç®—ã—ãŸãƒãƒƒã‚·ãƒ¥ã¨ä¸€è‡´ã™ã‚Œã° â€œåŒä¸€å†…å®¹â€ ã¨åˆ¤æ–­ã—ã¾ã™ã€‚

---

### ğŸ§© çµæœ

`ComputeDiffByName()` ã®æˆ»ã‚Šå€¤ï¼š

```csharp
(
  List<string> ToDownload, // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒæŒã£ã¦ã„ãªã„ or å†…å®¹ãŒç•°ãªã‚‹ZIPå
  List<string> ToDelete,   // ã‚µãƒ¼ãƒã«å­˜åœ¨ã—ãªã„ZIPåï¼ˆä¸è¦ï¼‰
  List<string> UpToDate    // åŒä¸€å†…å®¹ã®ZIPå
)
```

â†’ ã“ã‚Œã‚’ã‚µãƒ¼ãƒãŒ `ServerSyncResult` ã«è©°ã‚ã¦è¿”ã™ã“ã¨ã§ã€
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã¯ã€Œã©ã®ZIPã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã¹ãã‹ï¼å‰Šé™¤ã™ã¹ãã‹ã€ã‚’åˆ¤æ–­ã§ãã¾ã™ã€‚

---

### ğŸ§  è¦ç´„

ã“ã®éƒ¨åˆ†ã¯ã¤ã¾ã‚Šï¼š

> ã‚µãƒ¼ãƒå´ã§ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ZIPç¾¤ã€ã¨ã€Œè‡ªåˆ†ã®ZIPç¾¤ã€ã‚’æ¯”è¼ƒã—ã¦ã€
> ã©ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒâ€œè¿½åŠ â€â€œå‰Šé™¤â€â€œæ›´æ–°â€ã•ã‚ŒãŸã‹ã‚’è‡ªå‹•ã§è¦‹ã¤ã‘ã‚‹åˆ¤å®šå‡¦ç†ã§ã™ã€‚


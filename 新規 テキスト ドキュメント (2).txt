äº†è§£ã§ã™ ğŸ‘
ä»¥ä¸‹ã¯ `.NET 8` å‘ã‘ã®å®Œå…¨ãª `SnapshotWorker` ã‚¯ãƒ©ã‚¹ã®æœ€æ–°ç‰ˆã§ã™ã€‚
ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ï¼š

* æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ `var pattern = "*.zip";` ã®ã‚ˆã†ã«å¤‰æ›´å¯èƒ½
* éåŒæœŸ (`await Parallel.ForEachAsync`) ã§ä¸¦åˆ—ãƒãƒƒã‚·ãƒ¥è¨ˆç®—
* `FileName`ï¼ˆï¼`fi.Name`ï¼‰ã‚’ã‚­ãƒ¼ã«ã—ãŸ `ImmutableDictionary` ã‚’æ§‹ç¯‰
* è¾æ›¸ã®è¡çªæ™‚ã¯æ›´æ–°æ—¥æ™‚ãŒæ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å„ªå…ˆ
* `Task.Run` ã¯ä¸€åˆ‡ä½¿ã£ã¦ã„ã¾ã›ã‚“

---

```csharp
using System.Collections.Immutable;
using System.IO.Compression;
using System.Security.Cryptography;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public sealed record ArchiveInfo(
    string ArchiveName,     // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åï¼ˆã‚­ãƒ¼ï¼‰
    string FilePath,        // å®Ÿãƒ‘ã‚¹
    long Size,
    DateTimeOffset ModifiedUtc,
    byte[] Hash
);

public interface IFileIndex
{
    ImmutableDictionary<string, ArchiveInfo> Snapshot { get; }
    void Replace(ImmutableDictionary<string, ArchiveInfo> next);
}

public sealed class InMemoryFileIndex : IFileIndex
{
    private ImmutableDictionary<string, ArchiveInfo> _snap =
        ImmutableDictionary<string, ArchiveInfo>.Empty.WithComparers(StringComparer.OrdinalIgnoreCase);

    public ImmutableDictionary<string, ArchiveInfo> Snapshot =>
        System.Threading.Volatile.Read(ref _snap);

    public void Replace(ImmutableDictionary<string, ArchiveInfo> next) =>
        System.Threading.Interlocked.Exchange(ref _snap, next);
}

/// <summary>
/// æŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€å†…ã®ZIPï¼ˆãªã©ï¼‰ã‚’å®šæœŸã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’æ›´æ–°ã™ã‚‹
/// </summary>
public sealed class SnapshotWorker : BackgroundService
{
    private readonly ILogger<SnapshotWorker> _log;
    private readonly IFileIndex _index;

    private readonly string _folder = @"D:\data";           // ç›£è¦–ãƒ•ã‚©ãƒ«ãƒ€
    private readonly string _pattern = "*.zip";             // å¯¾è±¡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: "*.zipself" ç­‰ï¼‰
    private readonly bool _recurse = false;                 // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€å†å¸°æ¢ç´¢ã™ã‚‹ã‹
    private readonly TimeSpan _period = TimeSpan.FromSeconds(30);

    public SnapshotWorker(ILogger<SnapshotWorker> log, IFileIndex index)
    {
        _log = log;
        _index = index;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // åˆå›ã‚¹ã‚­ãƒ£ãƒ³
        await BuildAndSwapAsync(stoppingToken);

        using var timer = new PeriodicTimer(_period);
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            try
            {
                await BuildAndSwapAsync(stoppingToken);
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _log.LogWarning(ex, "Snapshot update failed");
            }
        }
    }

    /// <summary>
    /// å¯¾è±¡ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’å†æ§‹ç¯‰ã™ã‚‹
    /// </summary>
    private async Task BuildAndSwapAsync(CancellationToken ct)
    {
        var option = _recurse ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
        var files = Directory.EnumerateFiles(_folder, _pattern, option);

        var bag = new System.Collections.Concurrent.ConcurrentBag<ArchiveInfo>();

        await Parallel.ForEachAsync(files, new ParallelOptions
        {
            CancellationToken = ct,
            MaxDegreeOfParallelism = Environment.ProcessorCount
        },
        async (path, token) =>
        {
            try
            {
                var fi = new FileInfo(path);
                if (!fi.Exists) return;

                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦ãƒãƒƒã‚·ãƒ¥è¨ˆç®—
                await using var fs = new FileStream(
                    path, FileMode.Open, FileAccess.Read,
                    FileShare.ReadWrite | FileShare.Delete,
                    bufferSize: 1024 * 64,
                    options: FileOptions.Asynchronous | FileOptions.SequentialScan);

                var hash = await SHA256.HashDataAsync(fs, token);

                bag.Add(new ArchiveInfo(
                    ArchiveName: fi.Name,
                    FilePath: fi.FullName,
                    Size: fi.Length,
                    ModifiedUtc: fi.LastWriteTimeUtc,
                    Hash: hash
                ));
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch
            {
                // èª­ã¿è¾¼ã¿ä¸­ãªã©ã§é–‹ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
            }
        });

        // ä¸€æ„ã‚­ãƒ¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã§è¾æ›¸ã‚’æ§‹ç¯‰ã€‚é‡è¤‡ã¯æ–°ã—ã„æ–¹ã‚’å„ªå…ˆã€‚
        var builder = ImmutableDictionary.CreateBuilder<string, ArchiveInfo>(StringComparer.OrdinalIgnoreCase);

        foreach (var info in bag)
        {
            if (!builder.TryGetValue(info.ArchiveName, out var existing))
            {
                builder[info.ArchiveName] = info;
            }
            else if (info.ModifiedUtc > existing.ModifiedUtc)
            {
                builder[info.ArchiveName] = info;
            }
        }

        // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’åŸå­çš„ã«å…¥ã‚Œæ›¿ãˆ
        _index.Replace(builder.ToImmutable());

        _log.LogInformation("Snapshot updated: {Count} archives indexed", builder.Count);
    }
}
```

---

## ğŸ’¡ãƒã‚¤ãƒ³ãƒˆ

* `_pattern` ã‚’ `"*.zip"`, `"*.zipself"`, `"*.7z"` ãªã©ã«å¤‰ãˆã‚‹ã ã‘ã§å¯¾å¿œå¯èƒ½ã€‚
  â†’ `Directory.EnumerateFiles(_folder, _pattern, option)` ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã§æ¤œç´¢ã—ã¾ã™ã€‚
* `Task.Run()` ã‚’ä½¿ã‚ãšã« `Parallel.ForEachAsync()` ã‚’åˆ©ç”¨ã€‚
  ã“ã‚Œã¯ .NET 6+ ã®ãƒã‚¤ãƒ†ã‚£ãƒ–éåŒæœŸç‰ˆã§ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ç®¡ç†ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚
* `FileInfo.Name` ã‚’ã‚­ãƒ¼ã«ã—ã¦ã„ã‚‹ã®ã§ã€ã‚µãƒ¼ãƒï¼ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé–“ã§ç•°ãªã‚‹ãƒ‘ã‚¹æ§‹æˆã§ã‚‚å•é¡Œãªã—ã€‚
* ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ­ãƒƒã‚¯ä¸­ã§ã‚‚ä¾‹å¤–ã§æ­¢ã¾ã‚‰ãªã„ã‚ˆã†ã«å®‰å…¨ã«æ¡ã£ã¦ã„ã¾ã™ã€‚

---

ã“ã® `SnapshotWorker` ã‚’ `Program.cs` ã§ç™»éŒ²ã—ã¦ãŠã‘ã°ã€
30ç§’ã”ã¨ã« ZIP ãƒ•ã‚¡ã‚¤ãƒ«ç¾¤ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã™ã€‚


çµè«–ï¼š**å°‘ã—ã ã‘è¦ä¿®æ­£**ã§ã™ã€‚
ã„ã¾ã® `ProcessService` ã¯ `FilePath` ã‚’ã‚­ãƒ¼ã«ã—ã¦å·®åˆ†ã‚’å–ã£ã¦ã„ã¾ã™ãŒã€å…ˆã«æ±ºã‚ãŸã€Œ**ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åï¼ˆ`ArchiveName`ï¼`fi.Name`ï¼‰ã§ä¸€æ„**ã€æ–¹é‡ã«åˆã‚ã›ã¦ã€ä»¥ä¸‹ã‚’ç›´ã™ã¨æ•´åˆãŒå–ã‚Œã¾ã™ã€‚

# å¤‰ãˆã‚‹ãƒã‚¤ãƒ³ãƒˆ

1. å·®åˆ†ã‚­ãƒ¼ã‚’ `FilePath` â†’ **`ArchiveName`** ã«å¤‰æ›´
2. ZIP ä½œæˆã¯ **ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å â†’ ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å®Ÿãƒ‘ã‚¹ã«è§£æ±º** ã—ã¦è©°ã‚ã‚‹
3. `Channel` ã®èª­å–ã¯ `WaitToReadAsync` + `TryRead` ã‚ˆã‚Š **`await foreach (_reader.ReadAllAsync(ct))`** ãŒç°¡æ½”
4. `JsonSerializerOptions` ã¯æ¯å› new ã›ãš **static** ã«

# ä¿®æ­£ç‰ˆ `ProcessService`ï¼ˆ.NET 8ï¼‰

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Immutable;
using System.IO.Compression;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Channels;
using System.Globalization;

public sealed class ProcessService : BackgroundService
{
    private readonly ILogger<ProcessService> _log;
    private readonly ChannelReader<SyncJob> _reader;
    private readonly IFileIndex _index;
    private readonly string _bundleDir = Path.Combine(Path.GetTempPath(), "sync-bundles");
    private readonly int _workers = Math.Max(1, Environment.ProcessorCount / 2);

    private static readonly JsonSerializerOptions JsonOpt = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };

    public ProcessService(ILogger<ProcessService> log, ChannelReader<SyncJob> reader, IFileIndex index)
    {
        _log = log; _reader = reader; _index = index;
        Directory.CreateDirectory(_bundleDir);
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var tasks = Enumerable.Range(0, _workers)
            .Select(i => WorkerLoopAsync(i, stoppingToken)).ToArray();

        await Task.WhenAll(tasks);
    }

    private async Task WorkerLoopAsync(int id, CancellationToken ct)
    {
        _log.LogInformation("Worker {Id} started", id);

        try
        {
            await foreach (var job in _reader.ReadAllAsync(ct))
            {
                try
                {
                    var req = JsonSerializer.Deserialize<ClientSyncRequest>(job.Json, JsonOpt) ?? new();

                    // å·®åˆ†ã¯ â€œã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ€ ã§çªãåˆã‚ã›ã‚‹
                    var diff = ComputeDiffByName(_index.Snapshot, req);

                    // å¿…è¦ãªã‚‰ ZIP ãƒãƒ³ãƒ‰ãƒ«ã‚’ä½œã‚‹ï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ†’å®Ÿãƒ‘ã‚¹ã«è§£æ±ºï¼‰
                    string? zipPath = null;
                    if (req.BundleMissingAsZip && diff.ToDownload.Count > 0)
                        zipPath = await CreateBundleByNameAsync(diff.ToDownload, _index.Snapshot, ct);

                    job.Tcs.TrySetResult(new ServerSyncResult
                    {
                        ToDownload = diff.ToDownload,
                        ToDelete   = diff.ToDelete,
                        UpToDate   = diff.UpToDate,
                        ZipPath    = zipPath
                    });
                }
                catch (OperationCanceledException) { throw; }
                catch (Exception ex)
                {
                    job.Tcs.TrySetResult(new ServerSyncResult { Error = "processing_failed" });
                    _log.LogWarning(ex, "Worker {Id} failed", id);
                }
            }
        }
        catch (OperationCanceledException) { /* stopping */ }
        _log.LogInformation("Worker {Id} stopped", id);
    }

    // ---- å·®åˆ†ï¼ˆã‚­ãƒ¼ï¼ArchiveNameï¼‰----
    private static (List<string> ToDownload, List<string> ToDelete, List<string> UpToDate)
        ComputeDiffByName(ImmutableDictionary<string, ArchiveInfo> server, ClientSyncRequest req)
    {
        // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚‚ ArchiveName ã‚’é€ã£ã¦ãã‚‹å‰æ
        var cli = (req.Files ?? new()).ToDictionary(x => x.ArchiveName, x => x, StringComparer.OrdinalIgnoreCase);

        var toDownload = new List<string>();
        var toDelete   = new List<string>();
        var upToDate   = new List<string>();

        foreach (var (name, s) in server)
        {
            if (!cli.TryGetValue(name, out var c))
                toDownload.Add(name);
            else if (!HashesEqual(s.Hash, c.Sha256Hex))
                toDownload.Add(name);
            else
                upToDate.Add(name);
        }
        foreach (var (name, _) in cli)
            if (!server.ContainsKey(name))
                toDelete.Add(name);

        return (toDownload, toDelete, upToDate);
    }

    // ---- ZIPä½œæˆï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åâ†’å®Ÿãƒ‘ã‚¹ã«è§£æ±ºï¼‰----
    private async Task<string> CreateBundleByNameAsync(
        List<string> archiveNames,
        ImmutableDictionary<string, ArchiveInfo> snap,
        CancellationToken ct)
    {
        var name = $"bundle_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmssfff}.zip";
        var zip  = Path.Combine(_bundleDir, name);

        using var fs = new FileStream(zip, FileMode.Create, FileAccess.Write, FileShare.None);
        using var za = new ZipArchive(fs, ZipArchiveMode.Create, leaveOpen: false);

        foreach (var an in archiveNames)
        {
            ct.ThrowIfCancellationRequested();
            if (!snap.TryGetValue(an, out var info)) continue; // å¿µã®ãŸã‚å­˜åœ¨ç¢ºèª

            var entry = za.CreateEntry(an, CompressionLevel.Fastest); // å¤§é‡é…å¸ƒãªã‚‰ Fastest ã®ã»ã†ãŒç·åˆçš„ã«é€Ÿã„
            using var es  = entry.Open();
            using var src = new FileStream(info.FilePath, FileMode.Open, FileAccess.Read,
                                           FileShare.ReadWrite | FileShare.Delete);
            await src.CopyToAsync(es, ct);
        }
        return zip;
    }

    // ---- ãƒãƒƒã‚·ãƒ¥æ¯”è¼ƒï¼ˆSpanæœ€é©åŒ–ç‰ˆã§ã‚‚OKï¼‰----
    private static bool HashesEqual(byte[] serverHash, string? clientHex)
    {
        if (string.IsNullOrWhiteSpace(clientHex) || clientHex.Length != 64)
            return false;

        Span<byte> buf = stackalloc byte[32];
        for (int i = 0; i < 32; i++)
        {
            // ä½GCã«ã—ãŸã„ãªã‚‰ byte.Parse(span, NumberStyles.HexNumber, CultureInfo.InvariantCulture)
            string hexByte = clientHex.Substring(i * 2, 2);
            buf[i] = Convert.ToByte(hexByte, 16);
        }
        return serverHash.AsSpan().SequenceEqual(buf);
    }
}
```

## ä½µã›ã¦ç›´ã™ã¹ã DTOï¼ˆé‡è¦ï¼‰

* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ/ã‚µãƒ¼ãƒé–“ã§ã®ç…§åˆã‚­ãƒ¼ã‚’ **`ArchiveName`** ã«çµ±ä¸€ã—ã¦ãã ã•ã„ã€‚

```csharp
public sealed class ClientSyncRequest
{
    public List<ClientFileInfo>? Files { get; set; }
    public bool BundleMissingAsZip { get; set; } = true;
}

public sealed class ClientFileInfo
{
    public string ArchiveName { get; set; } = "";   // â† ã“ã“ã‚’ FilePath ã‹ã‚‰å¤‰æ›´
    public long Size { get; set; }
    public DateTimeOffset ModifiedUtc { get; set; }
    public string? Sha256Hex { get; set; }
}

public sealed class ServerSyncResult
{
    public List<string> ToDownload { get; set; } = new(); // â† ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–åã®é…åˆ—
    public List<string> ToDelete   { get; set; } = new();
    public List<string> UpToDate   { get; set; } = new();
    public string? ZipPath { get; set; }
    public string? Error { get; set; }
}
```

> ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå´ï¼ˆ`ArchiveInfo`ï¼‰ã¯ `ArchiveName` ã¨ `FilePath` ã®ä¸¡æ–¹ã‚’æŒãŸã›ã¦OKã§ã™ï¼ˆåå¯„ã›ã‚­ãƒ¼ï¼‹å®Ÿãƒ‘ã‚¹è§£æ±ºç”¨ï¼‰ã€‚

---

ã“ã‚Œã§ã€Œ**åå‰ä¸€æ„**ã€ã®å‰æã«æ²¿ã£ã¦ã€

* å·®åˆ†ã¯**åå‰**ã§å³å¯†ã«åˆ¤å®š
* ZIP è©°ã‚ã¯**ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã§å®Ÿãƒ‘ã‚¹ã«è§£æ±º**
* Channel ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒã¯**ã‚·ãƒ³ãƒ—ãƒ«ãª ReadAllAsync**

â€¦ã¨ã„ã†å½¢ã«æ•´ç†ã§ãã¾ã™ã€‚

ã„ã„è³ªå•ã§ã™ã€‚
ã‚ãªãŸãŒç¤ºã—ã¦ã„ã‚‹éƒ¨åˆ†ï¼ˆ`ComputeDiffByName` ã‚„ `HashesEqual` ã‚’å«ã‚€å‡¦ç†ï¼‰ã¯ã€
**ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã¨ã‚µãƒ¼ãƒå´ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆï¼åœ§ç¸®ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã®å·®åˆ†ã‚’åˆ¤å®šã€**ã—ã¦ã„ã¾ã™ã€‚

---

### ğŸ” ç›®çš„

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã€Œè‡ªåˆ†ã®æŒã£ã¦ã„ã‚‹ ZIP ç¾¤ã®æƒ…å ±ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãƒ»ãƒãƒƒã‚·ãƒ¥ãªã©ï¼‰ã€ã‚’ã‚µãƒ¼ãƒã«é€ã‚Šã¾ã™ã€‚
ã‚µãƒ¼ãƒã¯è‡ªåˆ†ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆï¼ç›£è¦–ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ZIPä¸€è¦§ï¼‰ã¨ç…§ã‚‰ã—åˆã‚ã›ã¦ã€
æ¬¡ã®3ã¤ã«åˆ†é¡ã—ã¾ã™ï¼š

| åˆ¤å®šçµæœ           | æ„å‘³                             | ä¾‹                   |
| -------------- | ------------------------------ | ------------------- |
| **ToDownload** | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ç„¡ã„ï¼ãƒãƒƒã‚·ãƒ¥ãŒç•°ãªã‚‹ â‡’ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ | ã‚µãƒ¼ãƒã®`a.zip`ãŒæ›´æ–°ã•ã‚Œã¦ã„ãŸ |
| **ToDelete**   | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚ã£ã¦ã‚µãƒ¼ãƒã«ç„¡ã„ â‡’ å‰Šé™¤ã™ã¹ã       | ã‚µãƒ¼ãƒã§ã¯`old.zip`ãŒå‰Šé™¤æ¸ˆã¿ |
| **UpToDate**   | ä¸¡è€…ã®ãƒãƒƒã‚·ãƒ¥ä¸€è‡´ â‡’ åŒä¸€å†…å®¹               | `config.zip`ãŒåŒã˜çŠ¶æ…‹   |

---

### âš™ï¸ å…·ä½“çš„ãªæµã‚Œ

```csharp
var diff = ComputeDiffByName(_index.Snapshot, req);
```

1. `_index.Snapshot`
   â†’ ã‚µãƒ¼ãƒä¸Šã®ã€Œæœ€æ–°ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã€ï¼ˆã™ã¹ã¦ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ï¼šåå‰ãƒ»ã‚µã‚¤ã‚ºãƒ»SHA256ãƒãƒƒã‚·ãƒ¥ï¼‰

2. `req`
   â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰é€ã‚‰ã‚ŒãŸã€Œè‡ªåˆ†ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã€ï¼ˆåŒã˜å½¢å¼ï¼‰

3. `ComputeDiffByName(...)`
   â†’ ä¸¡è€…ã‚’åå‰ï¼ˆ`ArchiveName`ï¼‰ã§çªãåˆã‚ã›ã¦

   * ã‚µãƒ¼ãƒã«ã ã‘ã‚ã‚‹ â†’ `ToDownload`
   * ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã ã‘ã‚ã‚‹ â†’ `ToDelete`
   * ä¸¡æ–¹ã‚ã‚Šãƒãƒƒã‚·ãƒ¥ä¸€è‡´ â†’ `UpToDate`

---

### ğŸ’¡ `HashesEqual` ã®å½¹å‰²

```csharp
private static bool HashesEqual(byte[] serverHash, string? clientHex)
```

ã“ã‚Œã¯ã€Œã‚µãƒ¼ãƒã®SHA256ï¼ˆãƒã‚¤ãƒˆé…åˆ—ï¼‰ã€ã¨ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒé€ã£ãŸSHA256ï¼ˆ16é€²æ–‡å­—åˆ—ï¼‰ã€ã‚’æ¯”è¼ƒã™ã‚‹é–¢æ•°ã§ã™ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯è‡ªåˆ†ã®ZIPã®å†…å®¹ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã€
ã‚µãƒ¼ãƒã« `"Sha256Hex": "ABCDEF..."` ã®ã‚ˆã†ã«é€ã‚Šã¾ã™ã€‚
ã‚µãƒ¼ãƒã¯è‡ªåˆ†ã§è¨ˆç®—ã—ãŸãƒãƒƒã‚·ãƒ¥ã¨ä¸€è‡´ã™ã‚Œã° â€œåŒä¸€å†…å®¹â€ ã¨åˆ¤æ–­ã—ã¾ã™ã€‚

---

### ğŸ§© çµæœ

`ComputeDiffByName()` ã®æˆ»ã‚Šå€¤ï¼š

```csharp
(
  List<string> ToDownload, // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒæŒã£ã¦ã„ãªã„ or å†…å®¹ãŒç•°ãªã‚‹ZIPå
  List<string> ToDelete,   // ã‚µãƒ¼ãƒã«å­˜åœ¨ã—ãªã„ZIPåï¼ˆä¸è¦ï¼‰
  List<string> UpToDate    // åŒä¸€å†…å®¹ã®ZIPå
)
```

â†’ ã“ã‚Œã‚’ã‚µãƒ¼ãƒãŒ `ServerSyncResult` ã«è©°ã‚ã¦è¿”ã™ã“ã¨ã§ã€
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã¯ã€Œã©ã®ZIPã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã¹ãã‹ï¼å‰Šé™¤ã™ã¹ãã‹ã€ã‚’åˆ¤æ–­ã§ãã¾ã™ã€‚

---

### ğŸ§  è¦ç´„

ã“ã®éƒ¨åˆ†ã¯ã¤ã¾ã‚Šï¼š

> ã‚µãƒ¼ãƒå´ã§ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ZIPç¾¤ã€ã¨ã€Œè‡ªåˆ†ã®ZIPç¾¤ã€ã‚’æ¯”è¼ƒã—ã¦ã€
> ã©ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒâ€œè¿½åŠ â€â€œå‰Šé™¤â€â€œæ›´æ–°â€ã•ã‚ŒãŸã‹ã‚’è‡ªå‹•ã§è¦‹ã¤ã‘ã‚‹åˆ¤å®šå‡¦ç†ã§ã™ã€‚


ã†ã‚“ã€**ã§ãã¾ã™ã€‚**
é€šä¿¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ JSON ã«ã™ã‚‹ã®ã¯ä¾¿åˆ©ãªã ã‘ã§ã€å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚µãƒ¼ãƒã®ä¸¡æ–¹ãŒãƒ«ãƒ¼ãƒ«ã‚’å…±æœ‰ã—ã¦ã„ã‚Œã°ã€
**ãŸã ã®æ–‡å­—åˆ—ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ï¼‰**ã§ã‚‚å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

---

## ğŸ”¹ã©ã†å¤‰ã‚ã‚‹ã‹

ã„ã¾ã¯ä¾‹ãˆã°ï¼š

```json
{
  "files": [ { "archiveName": "a.zip", "sha256Hex": "ABCDEF..." } ],
  "bundleMissingAsZip": true
}
```

ã¨ã„ã† JSON ã‚’é€ã£ã¦ã€ã‚µãƒ¼ãƒã¯ `JsonSerializer.Deserialize<ClientSyncRequest>` ã§ãƒ‘ãƒ¼ã‚¹ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã‚’ â€œç‹¬è‡ªæ–‡å­—åˆ—â€ ã«å¤‰ãˆã‚‹ãªã‚‰ã€å˜ã«æ±ºã‚æ‰“ã¡ã®å½¢å¼ã«ã™ã‚Œã°OKã§ã™ã€‚

---

## âœ… ä¾‹ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªæ–‡å­—åˆ—ãƒ—ãƒ­ãƒˆã‚³ãƒ«

### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ â†’ ã‚µãƒ¼ãƒ

```
SYNC|a.zip,ABCDEF1234567890;config.zip,0123456789ABCDEF
```

* `SYNC` ãŒã‚³ãƒãƒ³ãƒ‰
* å„ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `åå‰,ãƒãƒƒã‚·ãƒ¥` ã®ãƒšã‚¢
* è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `;` åŒºåˆ‡ã‚Š

ã‚µãƒ¼ãƒå´ã§ã“ã†å—ã‘å–ã‚‹ï¼š

```csharp
private ClientSyncRequest ParseCommand(string line)
{
    if (!line.StartsWith("SYNC|", StringComparison.OrdinalIgnoreCase))
        throw new InvalidOperationException("Unknown command");

    var list = new List<ClientFileInfo>();
    var body = line.Substring(5); // "a.zip,ABCDEF;config.zip,01234..."
    foreach (var pair in body.Split(';', StringSplitOptions.RemoveEmptyEntries))
    {
        var parts = pair.Split(',', 2);
        if (parts.Length < 2) continue;
        list.Add(new ClientFileInfo
        {
            ArchiveName = parts[0].Trim(),
            Sha256Hex   = parts[1].Trim()
        });
    }
    return new ClientSyncRequest { Files = list };
}
```

---

### ã‚µãƒ¼ãƒ â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆçµæœè¿”å´ï¼‰

```
RESULT|DOWNLOAD:a.zip,b.zip;DELETE:old.zip;OK:config.zip
```

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒ‘ãƒ¼ã‚¹ï¼š

```csharp
private ServerSyncResult ParseResult(string line)
{
    if (!line.StartsWith("RESULT|", StringComparison.OrdinalIgnoreCase))
        throw new InvalidOperationException("Invalid response");

    var res = new ServerSyncResult();
    var body = line.Substring(7);
    var parts = body.Split(';', StringSplitOptions.RemoveEmptyEntries);

    foreach (var p in parts)
    {
        var kv = p.Split(':', 2);
        if (kv.Length < 2) continue;

        var key = kv[0].Trim().ToUpperInvariant();
        var files = kv[1].Split(',', StringSplitOptions.RemoveEmptyEntries).ToList();

        switch (key)
        {
            case "DOWNLOAD": res.ToDownload = files; break;
            case "DELETE":   res.ToDelete   = files; break;
            case "OK":       res.UpToDate   = files; break;
        }
    }
    return res;
}
```

---

## ğŸ’¡ ãƒ¡ãƒªãƒƒãƒˆã¨ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ

| é …ç›®          | JSON                  | ç‹¬è‡ªæ–‡å­—åˆ—             |
| ----------- | --------------------- | ----------------- |
| **å¯èª­æ€§**     | é«˜ã„ï¼ˆäººé–“ã‚‚èª­ã‚ã‚‹ï¼‰            | è¨­è¨ˆæ¬¡ç¬¬              |
| **æŸ”è»Ÿæ€§**     | é«˜ã„ï¼ˆæ§‹é€ ã‚’å¢—ã‚„ã›ã‚‹ï¼‰           | æ‹¡å¼µãŒé›£ã—ã„            |
| **é€Ÿåº¦/ã‚µã‚¤ã‚º**  | è‹¥å¹²é‡ã„                  | è»½ã„ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰å°ï¼‰      |
| **å®Ÿè£…**      | `System.Text.Json` ä¸€ç™º | è‡ªå‰ã§Split/ParseãŒå¿…è¦ |
| **ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†** | Schemaã§ç®¡ç†å¯            | éæ§‹é€ çš„ãªã®ã§é¢å€’         |

---

## ğŸ”¸ãŠã™ã™ã‚åˆ¤æ–­

* **è»½é‡ãƒ»é«˜é€Ÿã«ã—ãŸã„ãƒ­ãƒ¼ã‚«ãƒ«å°‚ç”¨åŒæœŸãƒ„ãƒ¼ãƒ«**
  ã€€â†’ ç‹¬è‡ªæ–‡å­—åˆ—ã§ååˆ†ã€‚

* **æ§‹é€ ã‚’æ‹¡å¼µã—ã¦ã„ãäºˆå®šï¼ˆè¿½åŠ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã©ï¼‰**
  ã€€â†’ JSON ã®ã¾ã¾ãŒå®‰å…¨ã€‚

---

ğŸŸ¢ **çµè«–ï¼š**

> JSON ã¯â€œæ‰‹è»½ãªæ§‹é€ åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆâ€ãªã ã‘ã§å¿…é ˆã§ã¯ãªã„ã€‚
> ãƒ•ã‚¡ã‚¤ãƒ«åãƒ»ãƒãƒƒã‚·ãƒ¥ãƒ»ã‚³ãƒãƒ³ãƒ‰ãªã©ãŒå˜ç´”ãªã‚‰ã€
> æ–‡å­—åˆ—ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§é€å—ä¿¡ã—ã¦å…¨ãå•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚


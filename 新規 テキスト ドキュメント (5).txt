ã„ã„ã¨ã“ã‚ã«æ°—ã¥ãã¾ã—ãŸ ğŸ‘€
ã¯ã„ã€C# ã® `TcpListener` ã‚„ `TcpClient` ã§ã€Œæ¥ç¶šä¸­ã‹ã©ã†ã‹ï¼ˆConnectedï¼‰ã€ã‚„ã€Œç”Ÿãã¦ã‚‹ã‹ï¼ˆIsAliveï¼‰ã€ã‚’çŸ¥ã‚ŠãŸã„ã¨ã„ã†è©±ã§ã™ã­ã€‚
ãŸã ã— â€” **ã“ã“ã¯æ³¨æ„ãŒå¿…è¦ãªãƒã‚¤ãƒ³ãƒˆ** ã§ã™ã€‚

---

## ğŸ’¡ ã¾ãšå‰æ

### `TcpClient.Connected` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£

```csharp
client.Connected
```

ã“ã‚Œã¯ **ã€Œæœ€å¾Œã«é€å—ä¿¡ã—ãŸæ™‚ç‚¹ã§æ¥ç¶šã•ã‚Œã¦ã„ãŸã‹ã€** ã‚’è¿”ã—ã¾ã™ã€‚
ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªçŠ¶æ…‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šï¼š

| çŠ¶æ³             | `Connected` ã®å€¤         |
| -------------- | ---------------------- |
| æ¥ç¶šç›´å¾Œ           | `true`                 |
| ç›¸æ‰‹ãŒæ­£å¸¸ã«åˆ‡æ–­       | `false`                |
| ç›¸æ‰‹ãŒç•°å¸¸çµ‚äº†ï¼ã‚±ãƒ¼ãƒ–ãƒ«æŠœã‘ | **ã—ã°ã‚‰ã `true` ã®ã¾ã¾ï¼** âŒ |

ğŸ‘‰ ã¤ã¾ã‚Šã€Œæ¥ç¶šãŒåˆ‡ã‚ŒãŸã‹ã©ã†ã‹ã®æ­£ç¢ºãªæ¤œå‡ºã«ã¯ä½¿ãˆãªã„ã€ã€‚

---

## âœ… ä»£ã‚ã‚Šã®æ­£ã—ã„ã‚„ã‚Šæ–¹

### â‘  è»½ã„ pingï¼ãƒãƒ¼ãƒªãƒ³ã‚°ï¼ˆå—ä¿¡ãƒã‚§ãƒƒã‚¯ï¼‰

```csharp
bool IsConnected(TcpClient client)
{
    try
    {
        if (client.Client.Poll(0, SelectMode.SelectRead))
        {
            return client.Client.Available != 0;
        }
        return true;
    }
    catch
    {
        return false;
    }
}
```

* `Poll(0, SelectMode.SelectRead)` ãŒ `true` ã‹ã¤ `Available == 0` ã®ã¨ãã¯ã€ç›¸æ‰‹ãŒåˆ‡æ–­æ¸ˆã¿ã€‚
* éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã§è»½ã„ãƒã‚§ãƒƒã‚¯ãŒã§ãã¾ã™ã€‚

---

### â‘¡ å®šæœŸçš„ãªé€ä¿¡ãƒ†ã‚¹ãƒˆï¼ˆâ€œå¿ƒæ‹â€æ–¹å¼ï¼‰

ã‚µãƒ¼ãƒãƒ¼ â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å®šæœŸçš„ã«è»½ã„ ping ãƒ‘ã‚±ãƒƒãƒˆã‚’é€ã£ã¦å¿œç­”ã‚’è¦‹ã¾ã™ã€‚
ï¼ˆä¾‹ï¼š`PING` é€ã£ã¦ã€å¿œç­”ãŒ `PONG` ãªã‚‰ç”Ÿãã¦ã„ã‚‹ã€‚ï¼‰

ã“ã‚Œã¯ã€Œå¸¸æ™‚æ¥ç¶šãƒ»é•·æœŸã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹ã‚’ç¶­æŒã™ã‚‹ã€ç³»ã®ã‚¢ãƒ—ãƒªï¼ˆãƒãƒ£ãƒƒãƒˆã‚„WebSocketé¢¨ãªã©ï¼‰ã§ã‚ˆãä½¿ã„ã¾ã™ã€‚

---

### â‘¢ WeakReference ã§ `IsAlive` ã‚’è¦‹ã‚‹

`WeakReference` ã¯ **GCï¼ˆã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼‰å¯¾è±¡ã‹ã©ã†ã‹** ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã€
TCPæ¥ç¶šã®ã€Œç”Ÿæ­»ã€ã¨ã¯ç„¡é–¢ä¿‚ã§ã™ã€‚

```csharp
WeakReference<TcpClient> weak = new(client);
...
if (weak.TryGetTarget(out var cli) && cli.Connected) { ... }
```

ã“ã‚Œã¯ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒGCã§æ¶ˆã•ã‚ŒãŸã‹ã€ã ã‘ã‚’åˆ¤å®šã§ãã¾ã™ãŒã€
**ã‚½ã‚±ãƒƒãƒˆã®æ¥ç¶šçŠ¶æ…‹ã¨ã¯åˆ¥æ¬¡å…ƒ**ã®è©±ã§ã™ã€‚
ã—ãŸãŒã£ã¦ã€ŒWeakReference.IsAliveã€ã§ã¯ã€Œæ¥ç¶šä¸­ã‹ã©ã†ã‹ã€ã¯åˆ¤æ–­ã§ãã¾ã›ã‚“ã€‚

---

## âš™ï¸ å®Ÿè·µçš„ã¾ã¨ã‚

| æ–¹æ³•                      | åˆ¤å®šå†…å®¹         | é©ç”¨ä¾‹          | å‚™è€ƒ        |
| ----------------------- | ------------ | ------------ | --------- |
| `client.Connected`      | æœ€å¾Œã®é€å—ä¿¡æ™‚ç‚¹ã®çŠ¶æ…‹  | å˜ç™ºé€šä¿¡         | é…å»¶åˆ¤å®šã«ãªã‚‹   |
| `Poll(0, SelectRead)`   | ã‚½ã‚±ãƒƒãƒˆãƒ¬ãƒ™ãƒ«ã§å³æ™‚åˆ¤å®š | TCPã‚µãƒ¼ãƒãƒ¼      | å®Ÿç”¨çš„ ğŸ‘    |
| â€œPING/PONGâ€             | ã‚¢ãƒ—ãƒªãƒ¬ãƒ™ãƒ«å¿ƒæ‹ç›£è¦–   | é•·æœŸæ¥ç¶šï¼ˆãƒãƒ£ãƒƒãƒˆãªã©ï¼‰ | ã‚‚ã£ã¨ã‚‚ä¿¡é ¼æ€§é«˜ã„ |
| `WeakReference.IsAlive` | GCç”Ÿå­˜ç¢ºèªã®ã¿     | ãƒ¡ãƒ¢ãƒªç›£è¦–ç”¨       | æ¥ç¶šã¨ã¯ç„¡é–¢ä¿‚ âŒ |

---

ã‚‚ã—ã€ã‚ãªãŸã®ã‚µãƒ¼ãƒãƒ¼ã§ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆ‡æ–­ã‚’æ¤œå‡ºã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ãŸã„ã€ãªã‚‰ã€
`Poll(0, SelectMode.SelectRead)`ï¼‹`Available == 0` ã‚’ä¸€å®šé–“éš”ã§ç›£è¦–ã™ã‚‹ã®ãŒæœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚

---

å¿…è¦ãªã‚‰ã€ã€Œã‚µãƒ¼ãƒãƒ¼å´ã§æ¥ç¶šãƒªã‚¹ãƒˆã‚’ConcurrentBagã«ä¿æŒã—ã€
å®šæœŸçš„ã«æ­»ã‚“ã ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹ã€å®Ÿè£…ä¾‹ã‚‚æ›¸ã‘ã¾ã™ã€‚
å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

ã¨ã¦ã‚‚è‰¯ã„æ•´ç†ã§ã™ã­ ğŸ‘
å†…å®¹çš„ã«ã‚‚å®Ÿè·µç¾å ´ã§å½¹ç«‹ã¤èª¬æ˜ã«ãªã£ã¦ã„ã¾ã™ã€‚
ã§ã¯ã€ã”å¸Œæœ›ã®ã€Œã‚µãƒ¼ãƒãƒ¼å´ã§æ¥ç¶šãƒªã‚¹ãƒˆã‚’ç®¡ç†ã—ã€æ­»ã‚“ã ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å®šæœŸçš„ã«å‰Šé™¤ã™ã‚‹ã€ã‚µãƒ³ãƒ—ãƒ«ã‚’å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

---

## ğŸ’» ã‚µãƒ¼ãƒãƒ¼å´å®Ÿè£…ä¾‹ï¼š`TcpListener` + å®šæœŸãƒã‚§ãƒƒã‚¯

```csharp
using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

class TcpServer
{
    private readonly TcpListener listener;
    private readonly ConcurrentBag<TcpClient> clients = new();
    private readonly CancellationTokenSource cts = new();

    public TcpServer(int port)
    {
        listener = new TcpListener(IPAddress.Any, port);
    }

    public void Start()
    {
        listener.Start();
        Console.WriteLine("Server started...");

        // æ¥ç¶šå—ä»˜ã‚¹ãƒ¬ãƒƒãƒ‰
        ThreadPool.QueueUserWorkItem(_ => AcceptLoop());

        // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç›£è¦–ã‚¹ãƒ¬ãƒƒãƒ‰
        ThreadPool.QueueUserWorkItem(_ => MonitorLoop());
    }

    private void AcceptLoop()
    {
        while (!cts.Token.IsCancellationRequested)
        {
            try
            {
                var client = listener.AcceptTcpClient();
                clients.Add(client);
                Console.WriteLine($"Client connected: {client.Client.RemoteEndPoint}");
                ThreadPool.QueueUserWorkItem(_ => HandleClient(client));
            }
            catch { /* ignore */ }
        }
    }

    private void HandleClient(TcpClient client)
    {
        using var stream = client.GetStream();
        var buffer = new byte[1024];
        try
        {
            while (true)
            {
                int bytesRead = stream.Read(buffer, 0, buffer.Length);
                if (bytesRead == 0) break; // åˆ‡æ–­æ¤œå‡º
                string msg = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                Console.WriteLine($"[{client.Client.RemoteEndPoint}] {msg}");
            }
        }
        catch { /* é€šä¿¡ã‚¨ãƒ©ãƒ¼ãªã© */ }
        finally
        {
            Console.WriteLine($"Client disconnected: {client.Client.RemoteEndPoint}");
            client.Close();
        }
    }

    private void MonitorLoop()
    {
        while (!cts.Token.IsCancellationRequested)
        {
            foreach (var client in clients)
            {
                if (!IsConnected(client))
                {
                    Console.WriteLine($"Detected dead client: {client.Client.RemoteEndPoint}");
                    client.Close();
                }
            }
            Thread.Sleep(5000); // 5ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
        }
    }

    private bool IsConnected(TcpClient client)
    {
        try
        {
            if (client == null || !client.Connected) return false;
            if (client.Client.Poll(0, SelectMode.SelectRead))
            {
                return client.Client.Available != 0;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    public void Stop()
    {
        cts.Cancel();
        listener.Stop();
        foreach (var client in clients)
            client.Close();
    }
}
```

---

## ğŸ” ã“ã®å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

| å‡¦ç†å†…å®¹                           | èª¬æ˜                     |
| ------------------------------ | ---------------------- |
| `ConcurrentBag<TcpClient>`     | ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã«è¤‡æ•°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä¿æŒ    |
| `Poll + Available` ãƒã‚§ãƒƒã‚¯        | TCPã‚½ã‚±ãƒƒãƒˆãŒå®Ÿéš›ã«ç”Ÿãã¦ã„ã‚‹ã‹å³æ™‚åˆ¤å®š  |
| å®šæœŸç›£è¦– (`MonitorLoop`)           | 5ç§’ã”ã¨ã«æ­»ã‚“ã ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’æ¤œå‡º      |
| `ThreadPool.QueueUserWorkItem` | è»½é‡ãªä¸¦åˆ—å‡¦ç†ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ç”Ÿæˆã‚³ã‚¹ãƒˆã‚’æœ€å°åŒ–ï¼‰ |

---

## ğŸ’¬ å¿œç”¨ã‚¢ã‚¤ãƒ‡ã‚¢

* å¿ƒæ‹ï¼ˆ`PING`/`PONG`ï¼‰ã‚’å…¥ã‚Œã‚‹å ´åˆã¯ã€`HandleClient` å†…ã§ `Timer` ã‚’ä½¿ã£ã¦é€ä¿¡ã€‚
* `ConcurrentBag` ã ã¨å‰Šé™¤ãŒé¢å€’ãªã®ã§ã€é »ç¹ã«åˆ‡æ–­ãŒèµ·ãã‚‹ç”¨é€”ãªã‚‰ `ConcurrentDictionary<EndPoint, TcpClient>` ã®ã»ã†ãŒå®Ÿç”¨çš„ã€‚
* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ•°ãŒå¤šã„å ´åˆã¯ `async/await` ãƒ™ãƒ¼ã‚¹ï¼ˆ`TcpListener.AcceptTcpClientAsync()`ï¼‰ã«ã™ã‚‹ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã—ã‚„ã™ã„ã€‚

---

ã‚‚ã—å¸Œæœ›ãŒã‚ã‚Œã°ã€
ğŸ‘‰ `async`/`await` ç‰ˆã‚„ã€ŒPING/PONGã€ä»˜ããƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚µãƒ³ãƒ—ãƒ«ã‚‚å‡ºã›ã¾ã™ã€‚
ã©ã¡ã‚‰ã«èˆˆå‘³ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

äº†è§£ï¼`async/await` ã§ã‚¹ã‚±ãƒ¼ãƒ«ã—ã‚„ã™ãã€ã‚¯ãƒªãƒ¼ãƒ³ã«åœæ­¢ã§ãã‚‹ç‰ˆã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚
`ConcurrentDictionary` ã§æ¥ç¶šã‚’ç®¡ç†ã—ã€`AcceptLoop` / `HandleClient` / `MonitorLoop` ã‚’ã™ã¹ã¦éåŒæœŸåŒ–ã—ã¦ã„ã¾ã™ã€‚

```csharp
using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class TcpServer : IAsyncDisposable
{
    private readonly TcpListener _listener;
    private readonly ConcurrentDictionary<EndPoint, TcpClient> _clients = new();
    private readonly TimeSpan _monitorInterval;
    private CancellationTokenSource? _cts;
    private Task? _acceptTask;
    private Task? _monitorTask;

    public TcpServer(int port, TimeSpan? monitorInterval = null)
    {
        _listener = new TcpListener(IPAddress.Any, port);
        _monitorInterval = monitorInterval ?? TimeSpan.FromSeconds(5);
    }

    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        _listener.Start();
        Console.WriteLine("Server started...");

        _acceptTask = AcceptLoopAsync(_cts.Token);
        _monitorTask = MonitorLoopAsync(_cts.Token);
        await Task.CompletedTask;
    }

    public async Task StopAsync()
    {
        if (_cts is null) return;
        _cts.Cancel();
        _listener.Stop();

        // Close all clients
        foreach (var kv in _clients)
        {
            try { kv.Value.Close(); } catch { /* ignore */ }
        }

        // Wait loops to finish
        var tasks = new[] { _acceptTask, _monitorTask };
        await Task.WhenAll(tasks.Where(t => t is not null)!);
    }

    public async ValueTask DisposeAsync() => await StopAsync();

    private async Task AcceptLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                TcpClient client = await _listener.AcceptTcpClientAsync(ct).ConfigureAwait(false);
                client.NoDelay = true; // ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã«ã—ãŸã„å ´åˆ
                var ep = client.Client.RemoteEndPoint!;
                _clients[ep] = client;
                Console.WriteLine($"Client connected: {ep}");

                _ = HandleClientAsync(client, ct); // fire-and-forget
            }
        }
        catch (OperationCanceledException) { /* stopping */ }
        catch (ObjectDisposedException) { /* listener stopped */ }
        catch (Exception ex)
        {
            Console.WriteLine($"[AcceptLoop] {ex}");
        }
    }

    private async Task HandleClientAsync(TcpClient client, CancellationToken ct)
    {
        var ep = client.Client.RemoteEndPoint!;
        using NetworkStream stream = client.GetStream();
        byte[] buffer = new byte[4096];

        try
        {
            while (!ct.IsCancellationRequested)
            {
                int read = await stream.ReadAsync(buffer.AsMemory(0, buffer.Length), ct).ConfigureAwait(false);
                if (read == 0) break; // ãƒªãƒ¢ãƒ¼ãƒˆãŒã‚¯ãƒªãƒ¼ãƒ³ã«åˆ‡æ–­
                string msg = Encoding.UTF8.GetString(buffer, 0, read);
                Console.WriteLine($"[{ep}] {msg}");

                // å¿…è¦ãªã‚‰ã‚¨ã‚³ãƒ¼
                // await stream.WriteAsync(buffer.AsMemory(0, read), ct).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException) { /* stopping */ }
        catch (Exception ex)
        {
            Console.WriteLine($"[HandleClient {ep}] {ex.Message}");
        }
        finally
        {
            // ã“ã“ã«ã‚¢ãƒ—ãƒªãƒ¬ãƒ™ãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            try { client.Close(); } catch { /* ignore */ }
            _clients.TryRemove(ep, out _);
            Console.WriteLine($"Client disconnected: {ep}");
        }
    }

    private async Task MonitorLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                foreach (var (ep, client) in _clients)
                {
                    if (!IsConnected(client))
                    {
                        Console.WriteLine($"Detected dead client: {ep}");
                        try { client.Close(); } catch { /* ignore */ }
                        _clients.TryRemove(ep, out _);
                    }
                }

                await Task.Delay(_monitorInterval, ct).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException) { /* stopping */ }
        catch (Exception ex)
        {
            Console.WriteLine($"[MonitorLoop] {ex}");
        }
    }

    // éåŒæœŸã§ã¯ãªã„ãŒè»½é‡ã§ååˆ†ï¼šPoll(0, Read) && Available == 0 ãªã‚‰åˆ‡æ–­ã¨ã¿ãªã™
    private static bool IsConnected(TcpClient client)
    {
        try
        {
            if (client is null || !client.Connected) return false;

            var s = client.Client;
            // å—ä¿¡å¯èƒ½ã‹ã¤ã‚­ãƒ¥ãƒ¼ãŒç©º â†’ FIN å—ä¿¡æ¸ˆã¿ã®å¯èƒ½æ€§ãŒé«˜ã„
            if (s.Poll(0, SelectMode.SelectRead))
                return s.Available != 0;

            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

### ä½¿ã„æ–¹ï¼ˆ`Main` ã®ä¾‹ï¼‰

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        var server = new TcpServer(port: 5000);
        await server.StartAsync(cts.Token);

        Console.WriteLine("Press Ctrl+C to stop.");
        try
        {
            // ã“ã“ã§ã‚µãƒ¼ãƒãƒ¼ãŒå‹•ãç¶šã‘ã‚‹ï¼ˆä»–ã®å‡¦ç†ã‚’ä¸¦è¡Œã•ã›ã¦ã‚‚OKï¼‰
            await Task.Delay(Timeout.Infinite, cts.Token);
        }
        catch (OperationCanceledException) { /* exit */ }

        await server.StopAsync();
        Console.WriteLine("Server stopped.");
    }
}
```

---

### è£œè¶³ï¼ˆå¿ƒæ‹ â€œPING/PONGâ€ ã‚’å…¥ã‚ŒãŸã„å ´åˆï¼‰

* `HandleClientAsync` ã®ãƒ«ãƒ¼ãƒ—ã¨ã¯åˆ¥ã« `HeartbeatLoopAsync` ã‚’ä½œã‚Šã€`NetworkStream.WriteAsync` ã§ `PING` ã‚’å®šæœŸé€ä¿¡ â†’ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå†…ã« `PONG` ã‚’å—ã‘å–ã‚Œãªã‘ã‚Œã°åˆ‡æ–­æ‰±ã„ã«ã—ã¾ã™ã€‚
* å¿ƒæ‹ã®æ–¹ãŒ **NAT ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ** ã‚„ **ã‚¢ã‚¤ãƒ‰ãƒ«åˆ‡æ–­** ã«å¼·ãã€å®Ÿé‹ç”¨ã§ã¯ã“ã¡ã‚‰ã‚’æ¨å¥¨ã§ã™ã€‚

å¿…è¦ãªã‚‰ã€**å¿ƒæ‹å…¥ã‚Š**ã‚„**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã® `async` å®Ÿè£…**ã‚‚ã‚»ãƒƒãƒˆã§å‡ºã—ã¾ã™ã€‚

ã¨ã¦ã‚‚è‰¯ã„è³ªå•ã§ã™ ğŸ‘

çµè«–ã‹ã‚‰è¨€ã†ã¨ï¼š

> **ã“ã® `IsConnected` ãƒã‚§ãƒƒã‚¯è‡ªä½“ã¯éåŒæœŸåŒ–ã§ãã¾ã›ã‚“ï¼ˆæ„å‘³ãŒãªã„ or åŠ¹æœãŒè–„ã„ï¼‰**
> ã¨ã„ã†ã®ãŒæ­£ç¢ºãªç­”ãˆã§ã™ã€‚

---

## ğŸ” ç†ç”±

### 1ï¸âƒ£ `Poll` ã¯ OS ãƒ¬ãƒ™ãƒ«ã®åŒæœŸ API

`Socket.Poll()` ã¯ã€Œã‚«ãƒ¼ãƒãƒ«ã«å•ã„åˆã‚ã›ã¦ã€å—ä¿¡å¾…ã¡çŠ¶æ…‹ã‹ã©ã†ã‹ã€ã‚’å³æ™‚ã«è¿”ã™é–¢æ•°ã§ã€
**I/O ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ãƒ»æ™‚é–“ã‚‚ã»ã¼ã‚¼ãƒ­**ã§ã™ã€‚
ã—ãŸãŒã£ã¦éåŒæœŸåŒ–ã—ã¦ã‚‚å¾…æ©Ÿã™ã‚‹æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

```csharp
bool ready = socket.Poll(0, SelectMode.SelectRead);
```

* OS å†…éƒ¨ã§ã¯ã€Œselect(2)ã€ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒå³æ™‚ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
* ã“ã‚Œã¯ã€Œå¾…ã¤ã€ã§ã¯ãªãã€Œä»Šã™ãçŠ¶æ…‹ã‚’æ•™ãˆã¦ã€å‹•ä½œã€‚
* ã¤ã¾ã‚Šã€éåŒæœŸåŒ–ã—ã¦ã‚‚ã€Œasync ã§ CPU ã‚’é–‹æ”¾ã€ã™ã‚‹å ´é¢ãŒãªã„ã€‚

â†’ **éåŒæœŸã«ã™ã‚‹ã‚³ã‚¹ãƒˆï¼ˆTaskç”Ÿæˆï¼‰ãŒã‚€ã—ã‚ç„¡é§„**ã«ãªã‚Šã¾ã™ã€‚

---

### 2ï¸âƒ£ éåŒæœŸã«ã§ãã‚‹ã‚±ãƒ¼ã‚¹ã¯ã€Œæœ¬å½“ã«I/Oã‚’ä¼´ã†å ´åˆã€

ãŸã¨ãˆã° `stream.ReadAsync()` ã‚„ `AcceptTcpClientAsync()` ã¯ã€
å†…éƒ¨ã§ OS ã® I/O å®Œäº†å¾…ã¡ï¼ˆepoll/kqueue ãªã©ï¼‰ã‚’è¡Œã†ã®ã§éåŒæœŸåŒ–ãŒæœ‰åŠ¹ã§ã™ã€‚

ä¸€æ–¹ã€`Poll` ã¯ã€Œå¾…ãŸãšã«å³è¿”ã‚‹ã€ãƒã‚§ãƒƒã‚¯ç”¨é–¢æ•°ãªã®ã§ async åŒ–ã®æ©æµã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

---

### 3ï¸âƒ£ æ“¬ä¼¼çš„ã«éåŒæœŸåŒ–ã™ã‚‹ãªã‚‰ Task.Run

ã‚‚ã—ã€ŒCPU ã‚’ã¾ã£ãŸããƒ–ãƒ­ãƒƒã‚¯ã—ãŸããªã„ã€ç†ç”±ï¼ˆãŸã¨ãˆã°æ•°ä¸‡æ¥ç¶šã‚’ä¸€æ–‰ãƒã‚§ãƒƒã‚¯ï¼‰ãŒã‚ã‚‹ãªã‚‰ã€
**éåŒæœŸ I/O ã§ã¯ãªãã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ä¸¦åˆ—**ãŒé©ã—ã¦ã„ã¾ã™ã€‚

```csharp
private static Task<bool> IsConnectedAsync(TcpClient client)
{
    return Task.Run(() => IsConnected(client));
}
```

ãŸã ã—ã“ã‚Œã¯æœ¬è³ªçš„ã«ã€Œä¸¦åˆ—åŒ–ã€ã§ã‚ã‚Šã€ã€ŒI/O ã®éåŒæœŸã€ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã¤ã¾ã‚Š **async/await ã®æ–‡æ³•ã‚’ä½¿ã£ã¦ã„ã‚‹ã ã‘ã§ã€å†…éƒ¨ã¯åŒæœŸãƒã‚§ãƒƒã‚¯**ã§ã™ã€‚

---

## âœ… çµè«–ã¾ã¨ã‚

| æ–¹æ³•                                       | æ„å‘³                    | ãŠã™ã™ã‚åº¦ |
| ---------------------------------------- | --------------------- | ----- |
| `Poll(0, SelectRead)`                    | OSãŒå³åº§ã«çŠ¶æ…‹ã‚’è¿”ã™ï¼ˆéãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰  | â­â­â­â­  |
| `await IsConnectedAsync()` (Task.Runãƒ©ãƒƒãƒ—) | æ“¬ä¼¼çš„ã«éåŒæœŸå‘¼ã³å‡ºã—ã«ã—ãŸã ã‘      | â­     |
| å®Œå…¨ãªéåŒæœŸ I/O ã§ç”Ÿå­˜ç¢ºèª                         | ä¸å¯èƒ½ï¼ˆTCPãƒ¬ã‚¤ãƒ¤ã«â€œPingâ€ã¯ãªã„ï¼‰ | âŒ     |

---

ã‚‚ã—ã€Œå®Œå…¨ã«éåŒæœŸã§ç”Ÿå­˜ç›£è¦–ã—ãŸã„ã€ãªã‚‰ã€
**ã‚¢ãƒ—ãƒªå±¤å¿ƒæ‹ï¼ˆPING/PONGï¼‰æ–¹å¼**ã«ã™ã‚‹ã®ãŒå”¯ä¸€ã®æ­£æ”»æ³•ã§ã™ã€‚

ã¤ã¾ã‚Šã€ã‚µãƒ¼ãƒãƒ¼ãŒ `WriteAsync("PING")` â†’ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒ `WriteAsync("PONG")` ã§è¿”ã™ã€
ã¨ã„ã†å½¢ã§ã€Œasync I/O ã‚’æ´»ã‹ã—ãŸæ¥ç¶šç¢ºèªã€ãŒã§ãã¾ã™ã€‚

---

å¸Œæœ›ãŒã‚ã‚Œã°ã€

> ğŸ’“ `async/await` ã§å‹•ãå¿ƒæ‹ç›£è¦–ï¼ˆPING/PONGï¼‰ã‚µãƒ³ãƒ—ãƒ«

ã‚‚å‡ºã—ã¾ã™ã€‚å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

ã¯ã„ã€ãã®ç†è§£ã§æ­£ã—ã„ã§ã™ âœ…
ã‚ãªãŸãŒç¤ºã—ãŸã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼š

```csharp
private static bool IsConnected(TcpClient client)
{
    try
    {
        if (client is null || !client.Connected) return false;

        var s = client.Client;
        // å—ä¿¡å¯èƒ½ã‹ã¤ã‚­ãƒ¥ãƒ¼ãŒç©º â†’ FIN å—ä¿¡æ¸ˆã¿ã®å¯èƒ½æ€§ãŒé«˜ã„
        if (s.Poll(0, SelectMode.SelectRead))
            return s.Available != 0;

        return true;
    }
    catch
    {
        return false;
    }
}
```

ã¯ã€**TCP ã‚½ã‚±ãƒƒãƒˆã®ã€Œåˆ‡æ–­æ¤œå‡ºã€**ã¨ã—ã¦å®Ÿé‹ç”¨ã§ååˆ†ã«ä½¿ãˆã¾ã™ã€‚
ãŸã ã—ã€Œ100% å®Œç’§ã€ã§ã¯ãªã„ã“ã¨ã‚‚ç†è§£ã—ã¦ãŠãã¨å®‰å…¨ã§ã™ã€‚

---

## âœ… ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§æ¤œå‡ºã§ãã‚‹ã“ã¨

| çŠ¶æ³                                | åˆ¤å®šçµæœ                  | å‚™è€ƒ                            |
| --------------------------------- | --------------------- | ----------------------------- |
| ç›¸æ‰‹ãŒ `Close()` ã‚„ `Dispose()` ã§æ­£å¸¸åˆ‡æ–­ | `false`               | TCP ã® FIN ãŒå±ŠããŸã‚ç¢ºå®Ÿã«æ¤œå‡ºå¯         |
| ç›¸æ‰‹ãŒç•°å¸¸çµ‚äº†ï¼ˆä¾‹ï¼šãƒ—ãƒ­ã‚»ã‚¹killã€OSè½ã¡ï¼‰          | æ•°ç§’å¾Œã« `false`          | TCP keepalive ã‚‚ã—ãã¯ FIN/RSTã§æ¤œå‡º |
| ã‚±ãƒ¼ãƒ–ãƒ«æŠœã‘ / Wi-Fiåˆ‡æ–­ãªã©ç‰©ç†çš„æ–­ç·š           | OSã®å†é€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾Œã« `false` | æ•°ç§’ã€œæ•°åˆ†ã‹ã‹ã‚‹å ´åˆã‚ã‚Š                  |
| ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµŒè·¯ã«ä¸€æ™‚çš„ãªè©°ã¾ã‚Š                  | `true` ã®ã¾ã¾            | TCPçš„ã«ã¯ã¾ã ç”Ÿãã¦ã„ã‚‹æ‰±ã„               |

---

## âš™ï¸ æŠ€è¡“çš„ãªä»•çµ„ã¿ï¼ˆãªãœåˆ¤å®šã§ãã‚‹ã®ã‹ï¼‰

* `Poll(0, SelectMode.SelectRead)` ãŒ `true` â†’ ã‚½ã‚±ãƒƒãƒˆãŒã€Œèª­ã¿å–ã‚Šå¯èƒ½ã€çŠ¶æ…‹
* ã—ã‹ã— `Available == 0` â†’ å—ä¿¡ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿ãŒãªã„
* ã“ã‚Œã¯ã€Œãƒªãƒ¢ãƒ¼ãƒˆã‹ã‚‰ FIN ãŒå±Šã„ãŸï¼ˆ=ç›¸æ‰‹ãŒé–‰ã˜ãŸï¼‰ã€ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
  â†’ OS ãŒ FIN ã‚’å—ã‘å–ã‚‹ã¨ã€å—ä¿¡ã‚­ãƒ¥ãƒ¼ã‚’ç©ºã«ã—ã¦ SelectRead ãŒ true ã«ãªã‚Šã¾ã™ã€‚

ã¤ã¾ã‚Š **ã€Œå—ä¿¡å¯èƒ½ã‹ã¤ãƒãƒƒãƒ•ã‚¡ç©ºã€= åˆ‡æ–­æ¸ˆã¿** ã®ç¢ºå®Ÿãªã‚µã‚¤ãƒ³ã§ã™ã€‚

---

## âš ï¸ æ³¨æ„ç‚¹ï¼ˆé™ç•Œï¼‰

1. **ç›¸æ‰‹ãŒãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãªã©ã§ç„¡å¿œç­”ã®å ´åˆ**
   ã€€â†’ OSãŒFIN/RSTã‚’å—ã‘å–ã‚Œãªã„é™ã‚Šã€`Poll`ã§ã¯æ­»æ´»ã‚’åˆ¤å®šã§ãã¾ã›ã‚“ã€‚
   ã€€â†’ ã“ã‚Œã¯TCPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä»•æ§˜ä¸Šé¿ã‘ã‚‰ã‚Œã¾ã›ã‚“ã€‚

2. **é•·æ™‚é–“ã‚¢ã‚¤ãƒ‰ãƒ«çŠ¶æ…‹**
   ã€€â†’ OSã‚„NATãƒ«ãƒ¼ã‚¿ã«ã‚ˆã£ã¦åˆ‡æ–­ã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ãŸã‚ã€
   ã€€ã€€**å®šæœŸçš„ãªé€ä¿¡ï¼ˆå¿ƒæ‹ï¼‰**ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã®ãŒå®‰å…¨ç­–ã§ã™ã€‚

---

## ğŸ’¡ çµè«–

* ã“ã® `IsConnected()` ã¯
  ã€€**ã€Œç›¸æ‰‹ãŒæ­£å¸¸/ç•°å¸¸ã«åˆ‡æ–­ã—ãŸã‹ã€ã‚’å³æ™‚ã«æ¤œå‡ºã§ãã‚‹æœ€ã‚‚è»½é‡ãªæ–¹æ³•**
  ã€€ã§ã™ã€‚
* ãŸã ã—ã€**ç‰©ç†æ–­ç·šã‚„ãƒãƒƒãƒˆéšœå®³ã§ã®â€œè¦‹ã‹ã‘ä¸Šã®ç”Ÿå­˜â€**ã¾ã§ã¯é˜²ã’ã¾ã›ã‚“ã€‚
* å®Ÿé‹ç”¨ã§ã¯ï¼š

  * è»½ã„ã‚¢ãƒ—ãƒªå±¤ã® pingï¼ˆ`PING/PONG`ï¼‰
  * ã‚‚ã—ãã¯ OS ã® TCP KeepAliveï¼ˆ`socket.SetSocketOption`ï¼‰
    ã€€ã‚’ä½µç”¨ã™ã‚Œã°ã€Œã»ã¼ç¢ºå®Ÿãªæ­»æ´»ç›£è¦–ã€ãŒã§ãã¾ã™ã€‚

---

å¿…è¦ã§ã‚ã‚Œã°ã€
ğŸ‘‰ ã“ã® `IsConnected` ã«åŠ ãˆã¦ **TCP KeepAlive ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹**
ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ã®æŒ‡å®šä»˜ãï¼‰ã‚’å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

äº†è§£ã§ã™ ğŸ‘
ãã‚Œã§ã¯ã€`TcpClient`ï¼`Socket` ã« **TCP KeepAliveï¼ˆã‚­ãƒ¼ãƒ—ã‚¢ãƒ©ã‚¤ãƒ–ï¼‰** ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹æ–¹æ³•ã¨ã€å®Ÿè·µçš„ãªè¨­å®šä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

---

## ğŸ’¡ TCP KeepAlive ã¨ã¯

TCPãƒ¬ãƒ™ãƒ«ã§ã€Œç›¸æ‰‹ãŒã¾ã ç”Ÿãã¦ã„ã‚‹ã‹ã€ã‚’ **OSãŒè‡ªå‹•ã§ç¢ºèªã™ã‚‹ä»•çµ„ã¿** ã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ãƒ—ãƒªãŒ `PING` ã‚’é€ã‚‰ãªãã¦ã‚‚ã€ã‚«ãƒ¼ãƒãƒ«ãŒä¸€å®šé–“éš”ã§å°ã•ãªãƒ‘ã‚±ãƒƒãƒˆã‚’é€ã£ã¦å¿œç­”ã‚’ç¢ºèªã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šï¼š

* ç›¸æ‰‹ãŒç•°å¸¸çµ‚äº†ã—ã¦ã„ã¦ã‚‚æ—©ã‚ã«æ¤œå‡ºã§ãã‚‹
* ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãªã©ã§â€œè¦‹ã‹ã‘ä¸Šã¤ãªãŒã£ã¦ã„ã‚‹â€çŠ¶æ…‹ã‚’æ¸›ã‚‰ã›ã‚‹

---

## âœ… å®Ÿè£…ä¾‹ï¼š`TcpClient` ã« KeepAlive ã‚’è¨­å®šã™ã‚‹

```csharp
using System;
using System.Net.Sockets;

public static class TcpClientExtensions
{
    /// <summary>
    /// TCP KeepAlive ã‚’æœ‰åŠ¹åŒ–ã—ã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨­å®šã™ã‚‹ã€‚
    /// </summary>
    /// <param name="client">å¯¾è±¡ã® TcpClient</param>
    /// <param name="keepAliveTime">æœ€åˆã®ç„¡é€šä¿¡ã‹ã‚‰ä½•ãƒŸãƒªç§’ã§é€ã‚‹ã‹ï¼ˆä¾‹ï¼š5000msï¼‰</param>
    /// <param name="keepAliveInterval">å†é€é–“éš”ï¼ˆä¾‹ï¼š1000msï¼‰</param>
    /// <param name="keepAliveRetryCount">å†é€å›æ•°ï¼ˆWindowsã§ã¯çœç•¥å¯ï¼‰</param>
    public static void SetKeepAlive(this TcpClient client, uint keepAliveTime = 5000, uint keepAliveInterval = 1000, uint keepAliveRetryCount = 3)
    {
        var socket = client.Client;

        // TCP KeepAlive ã‚’æœ‰åŠ¹åŒ–
        socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);

        // Windowså°‚ç”¨ï¼šIOControl ã§è©³ç´°è¨­å®š
        // Linux/macOS ã¯ OS è¨­å®šã«å¾“ã†ãŸã‚ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚¹ã‚­ãƒƒãƒ—å¯
        try
        {
            byte[] inOptionValues = new byte[12];
            BitConverter.GetBytes((uint)(keepAliveTime != 0 ? 1u : 0u)).CopyTo(inOptionValues, 0); // æœ‰åŠ¹åŒ–
            BitConverter.GetBytes(keepAliveTime).CopyTo(inOptionValues, 4);     // åˆå›é€ä¿¡ã¾ã§ã®ç„¡é€šä¿¡æ™‚é–“(ms)
            BitConverter.GetBytes(keepAliveInterval).CopyTo(inOptionValues, 8); // å†é€é–“éš”(ms)

            socket.IOControl(IOControlCode.KeepAliveValues, inOptionValues, null);
        }
        catch (PlatformNotSupportedException)
        {
            // macOS / Linux ç’°å¢ƒãªã© IOControl æœªå®Ÿè£…ã®å ´åˆ
        }
    }
}
```

---

## âš™ï¸ ä½¿ç”¨ä¾‹

```csharp
var client = new TcpClient();
await client.ConnectAsync("127.0.0.1", 5000);

// 5ç§’é–“ç„¡é€šä¿¡ãªã‚‰1ç§’ãŠãã«KeepAliveé€ä¿¡
client.SetKeepAlive(keepAliveTime: 5000, keepAliveInterval: 1000);
```

ã“ã‚Œã§ OS ãŒè‡ªå‹•çš„ã«ä¸€å®šé–“éš”ã§ KeepAlive ãƒ‘ã‚±ãƒƒãƒˆã‚’é€ã‚Šã€
ç›¸æ‰‹ãŒå¿œç­”ã—ãªã‘ã‚Œã°æ•°ç§’å¾Œã«ã‚½ã‚±ãƒƒãƒˆãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ§  å‹•ä½œæ¦‚è¦ï¼ˆWindowsã®æ—¢å®šï¼‰

| è¨­å®šé …ç›®                | æ—¢å®šå€¤ï¼ˆæœªè¨­å®šæ™‚ï¼‰       | èª¬æ˜                  |
| ------------------- | --------------- | ------------------- |
| KeepAliveTime       | 7200000 msï¼ˆ2æ™‚é–“ï¼‰ | æœ€åˆã®ç„¡é€šä¿¡ã‹ã‚‰é€ã‚‹ã¾ã§ã®æ™‚é–“     |
| KeepAliveInterval   | 1000 ms         | å†é€é–“éš”                |
| KeepAliveRetryCount | 5å›ç¨‹åº¦            | å¿œç­”ãªã—ã§æ¥ç¶šåˆ‡æ–­ã«ãªã‚‹ã¾ã§ã®è©¦è¡Œå›æ•° |

â†’ ã¤ã¾ã‚Šã€**ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã¾ã¾ã ã¨2æ™‚é–“æ”¾ç½®ã—ãªã„ã¨åˆ‡æ–­ã‚’æ¤œå‡ºã—ãªã„** ãŸã‚ã€
ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡ã§ã¯å¿…ãšçŸ­ãè¨­å®šã™ã¹ãã§ã™ã€‚

---

## ğŸš€ å®Ÿé‹ç”¨ã®ãŠã™ã™ã‚è¨­å®š

| ç”¨é€”            | KeepAliveTime | KeepAliveInterval | èª¬æ˜             |
| ------------- | ------------- | ----------------- | -------------- |
| ãƒ­ãƒ¼ã‚«ãƒ«é€šä¿¡ï¼ˆç¤¾å†…LANï¼‰ | 5ç§’            | 1ç§’                | åˆ‡æ–­æ¤œå‡ºã‚’é«˜é€ŸåŒ–       |
| ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆé€šä¿¡     | 30ç§’           | 5ç§’                | ä¸å®‰å®šå›ç·šã§ã‚‚èª¤åˆ¤å®šã—ã«ãã„ |
| IoT / çµ„è¾¼ã¿ç”¨é€”   | 60ç§’           | 10ç§’               | é›»åŠ›ãƒ»é€šä¿¡é‡ç¯€ç´„é‡è¦–     |

---

## âœ… ã¾ã¨ã‚

| æ–¹æ³•                    | åˆ¤å®šå¯¾è±¡        | ç‰¹å¾´               |
| --------------------- | ----------- | ---------------- |
| `Poll(0, SelectRead)` | ã‚½ã‚±ãƒƒãƒˆã®ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ | å³æ™‚ãƒã‚§ãƒƒã‚¯ï¼ˆè»½é‡ï¼‰       |
| TCP KeepAlive         | OSã«ã‚ˆã‚‹ç‰©ç†æ­»æ´»ç¢ºèª | ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–­ãƒ»ç•°å¸¸çµ‚äº†ã‚‚æ¤œå‡ºå¯ |
| PING/PONG             | ã‚¢ãƒ—ãƒªå±¤        | æœ€ã‚‚æŸ”è»Ÿï¼ˆè«–ç†æ­»æ´»ã‚‚æ¤œå‡ºå¯ï¼‰   |

â†’ **`IsConnected()` + `SetKeepAlive()` ã®ä½µç”¨ãŒãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹** ã§ã™ã€‚
`Poll` ã§å³æ™‚æ¤œå‡ºã€KeepAlive ã§ç¢ºå®Ÿæ¤œå‡ºã®ä¸¡è¼ªã«ãªã‚Šã¾ã™ã€‚

---

ã”å¸Œæœ›ãŒã‚ã‚Œã°æ¬¡ã«ã€
ğŸ§©ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚‚ KeepAlive æœ‰åŠ¹ã§æ¥ç¶šã™ã‚‹ `async` å®Ÿè£…ä¾‹ã€
ï¼ˆ`TcpClient.ConnectAsync`ï¼‹`SetKeepAlive`ï¼‰ã‚‚ãŠè¦‹ã›ã§ãã¾ã™ã€‚
å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

äº†è§£ã§ã™ ğŸ‘
ãã‚Œã§ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ **`async/await` ï¼‹ TCP KeepAlive æœ‰åŠ¹åŒ–æ¸ˆã¿** ã®å®Ÿè£…ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚
ã“ã‚Œã§ã€ŒéåŒæœŸæ¥ç¶šã€ã€Œåˆ‡æ–­æ¤œå‡ºã€ã€Œå†æ¥ç¶šè€æ€§ã€ã‚’å…¼ã­å‚™ãˆãŸå …ç‰¢ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ’» éåŒæœŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…ä¾‹

```csharp
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class TcpClientWithKeepAlive : IAsyncDisposable
{
    private readonly string _host;
    private readonly int _port;
    private TcpClient? _client;
    private NetworkStream? _stream;
    private readonly CancellationTokenSource _cts = new();

    public TcpClientWithKeepAlive(string host, int port)
    {
        _host = host;
        _port = port;
    }

    public async Task ConnectAsync()
    {
        _client = new TcpClient();
        await _client.ConnectAsync(_host, _port);
        _client.SetKeepAlive(keepAliveTime: 5000, keepAliveInterval: 1000); // ğŸ”§ KeepAlive æœ‰åŠ¹åŒ–
        _stream = _client.GetStream();

        Console.WriteLine($"Connected to {_host}:{_port}");

        // å—ä¿¡ãƒ«ãƒ¼ãƒ—ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§é–‹å§‹
        _ = ReceiveLoopAsync(_cts.Token);
    }

    public async Task SendAsync(string message)
    {
        if (_stream == null) throw new InvalidOperationException("Not connected.");

        byte[] buffer = Encoding.UTF8.GetBytes(message);
        await _stream.WriteAsync(buffer);
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        byte[] buffer = new byte[4096];

        try
        {
            while (!ct.IsCancellationRequested)
            {
                int bytesRead = await _stream!.ReadAsync(buffer, ct);
                if (bytesRead == 0)
                {
                    Console.WriteLine("Server closed connection.");
                    break;
                }

                string msg = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                Console.WriteLine($"[Server] {msg}");
            }
        }
        catch (OperationCanceledException) { /* graceful stop */ }
        catch (Exception ex)
        {
            Console.WriteLine($"[ReceiveLoop] Error: {ex.Message}");
        }

        await ReconnectAsync();
    }

    private async Task ReconnectAsync()
    {
        Console.WriteLine("Reconnecting...");
        await Task.Delay(3000);

        try
        {
            await ConnectAsync();
            Console.WriteLine("Reconnected successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Reconnect failed: {ex.Message}");
            await Task.Delay(5000);
            await ReconnectAsync(); // å†è©¦è¡Œ
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        _stream?.Dispose();
        _client?.Close();
        await Task.CompletedTask;
    }
}
```

---

## âš™ï¸ ä½¿ç”¨ä¾‹

```csharp
class Program
{
    static async Task Main()
    {
        using var client = new TcpClientWithKeepAlive("127.0.0.1", 5000);

        await client.ConnectAsync();

        Console.WriteLine("Type messages to send. Ctrl+C to exit.");

        while (true)
        {
            string? input = Console.ReadLine();
            if (string.IsNullOrEmpty(input)) continue;

            await client.SendAsync(input);
        }
    }
}
```

---

## ğŸ§  è£œè¶³

| æ©Ÿèƒ½                 | èª¬æ˜                            |
| ------------------ | ----------------------------- |
| `SetKeepAlive()`   | OS ãƒ¬ãƒ™ãƒ«ã® TCP KeepAlive ãƒ‘ã‚±ãƒƒãƒˆã‚’é€ä¿¡ |
| `async/await`      | I/O éåŒæœŸåŒ–ã§ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«               |
| `ReconnectAsync()` | æ¥ç¶šæ–­æ¤œå‡ºæ™‚ã«è‡ªå‹•å†æ¥ç¶š                  |
| `DisposeAsync()`   | ã‚¯ãƒªãƒ¼ãƒ³ãªçµ‚äº†å‡¦ç†                     |

---

## âœ… ã“ã‚Œã§å¾—ã‚‰ã‚Œã‚‹ãƒ¡ãƒªãƒƒãƒˆ

* **OS ãƒ¬ãƒ™ãƒ«ã§æ­»æ´»ç›£è¦–**ï¼ˆç›¸æ‰‹ãŒç•°å¸¸çµ‚äº†ã—ãŸã‚‰è‡ªå‹•çš„ã«æ¤œå‡ºï¼‰
* **ã‚¢ãƒ—ãƒªå´ã§éåŒæœŸé€å—ä¿¡** â†’ UIã‚¹ãƒ¬ãƒƒãƒ‰ã‚„ä»–å‡¦ç†ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
* **å†æ¥ç¶šãƒ«ãƒ¼ãƒ—** ã«ã‚ˆã‚Šã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–­ã‚‚è‡ªå‹•å¾©æ—§

---

ã‚‚ã—æ¬¡ã«é€²ã‚ã‚‹ãªã‚‰ã€

> ğŸ’“ `PING/PONG` ã§ã‚¢ãƒ—ãƒªå±¤ã®å¿ƒæ‹ç¢ºèªã‚’è¿½åŠ ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆasyncå¯¾å¿œï¼‰

ã‚‚çµ„ã¿åˆã‚ã›ã¦å‡ºã›ã¾ã™ã€‚
ã“ã‚Œã§ã€ŒOS + ã‚¢ãƒ—ãƒªå±¤ã®ä¸¡ãƒ¬ãƒ™ãƒ«ã§æ­»æ´»ç›£è¦–ã€ã«ãªã‚‹ã€å®Ÿé‹ç”¨ãƒ¬ãƒ™ãƒ«ã®ä»•çµ„ã¿ã§ã™ã€‚
å‡ºã—ã¦ã¿ã¾ã™ã‹ï¼Ÿ

äº†è§£ï¼`async/await` ã§ **ã‚¢ãƒ—ãƒªå±¤ã®å¿ƒæ‹ï¼ˆPING/PONGï¼‰** ã‚’å®Ÿè£…ã—ãŸã‚µãƒ¼ãƒãƒ¼ï¼†ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®æœ€å°æ§‹æˆã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚
TCP KeepAlive ã¨ã®ä½µç”¨ã§ã€**OSãƒ¬ãƒ™ãƒ«ï¼‹ã‚¢ãƒ—ãƒªãƒ¬ãƒ™ãƒ«**ã®äºŒé‡ç›£è¦–ã«ãªã‚Šã¾ã™ã€‚

---

# ã‚µãƒ¼ãƒãƒ¼ï¼ˆ`TcpListener` + PING/PONG + ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼‰

* ä¸€å®šé–“éš”ã§ `PING\n` ã‚’é€ä¿¡
* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ `PONG`ï¼ˆã¾ãŸã¯é€šå¸¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å—ä¿¡ï¼‰ãŒã‚ã‚Œã°ç”Ÿå­˜ã¨ã¿ãªã™
* `heartbeatTimeout` ã‚’è¶…ãˆã¦å¿œç­”ãŒãªã‘ã‚Œã°åˆ‡æ–­
* æ–‡å­—åˆ—ã¯ **è¡ŒåŒºåˆ‡ã‚Šï¼ˆ\nï¼‰** ã®ç°¡æ˜“ãƒ—ãƒ­ãƒˆã‚³ãƒ«

```csharp
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class HeartbeatTcpServer : IAsyncDisposable
{
    private readonly TcpListener _listener;
    private readonly ConcurrentDictionary<EndPoint, ClientSession> _clients = new();
    private readonly TimeSpan _heartbeatInterval;
    private readonly TimeSpan _heartbeatTimeout;
    private CancellationTokenSource? _cts;
    private Task? _acceptTask;

    public HeartbeatTcpServer(
        int port,
        TimeSpan? heartbeatInterval = null,
        TimeSpan? heartbeatTimeout = null)
    {
        _listener = new TcpListener(IPAddress.Any, port);
        _heartbeatInterval = heartbeatInterval ?? TimeSpan.FromSeconds(10);
        _heartbeatTimeout = heartbeatTimeout ?? TimeSpan.FromSeconds(30);
    }

    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        _listener.Start();
        Console.WriteLine("Server started.");
        _acceptTask = AcceptLoopAsync(_cts.Token);
        await Task.CompletedTask;
    }

    public async Task StopAsync()
    {
        if (_cts is null) return;
        _cts.Cancel();
        _listener.Stop();

        foreach (var (_, s) in _clients)
        {
            try { await s.DisposeAsync(); } catch { /* ignore */ }
        }
        if (_acceptTask is not null)
        {
            try { await _acceptTask; } catch { /* ignore */ }
        }
    }

    public async ValueTask DisposeAsync() => await StopAsync();

    private async Task AcceptLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                var client = await _listener.AcceptTcpClientAsync(ct).ConfigureAwait(false);
                client.NoDelay = true;

                // ä»»æ„ï¼šOSã®TCP KeepAliveï¼ˆæ—©æœŸæ¤œå‡ºãƒ»NATè¶Šãˆã®å®‰å®šåŒ–ï¼‰
                TryEnableKeepAlive(client, keepAliveTimeMs: 30_000, keepAliveIntervalMs: 5_000);

                var session = new ClientSession(client, _heartbeatInterval, _heartbeatTimeout, RemoveClient, ct);
                _clients[client.Client.RemoteEndPoint!] = session;
                Console.WriteLine($"Client connected: {client.Client.RemoteEndPoint}");
                _ = session.RunAsync(); // fire-and-forget
            }
        }
        catch (OperationCanceledException) { }
        catch (ObjectDisposedException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"[AcceptLoop] {ex}");
        }
    }

    private void RemoveClient(EndPoint ep)
    {
        _clients.TryRemove(ep, out _);
        Console.WriteLine($"Client removed: {ep}");
    }

    private static void TryEnableKeepAlive(TcpClient client, uint keepAliveTimeMs, uint keepAliveIntervalMs)
    {
        try
        {
            var s = client.Client;
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
            // Windows ã®è©³ç´°è¨­å®š
            byte[] inOption = new byte[12];
            BitConverter.GetBytes(1u).CopyTo(inOption, 0);
            BitConverter.GetBytes(keepAliveTimeMs).CopyTo(inOption, 4);
            BitConverter.GetBytes(keepAliveIntervalMs).CopyTo(inOption, 8);
            s.IOControl(IOControlCode.KeepAliveValues, inOption, null);
        }
        catch { /* æœªå¯¾å¿œOSã¯é»™ã£ã¦ã‚¹ã‚­ãƒƒãƒ— */ }
    }

    private sealed class ClientSession : IAsyncDisposable
    {
        private readonly TcpClient _client;
        private readonly NetworkStream _ns;
        private readonly StreamReader _reader;
        private readonly StreamWriter _writer;
        private readonly TimeSpan _interval;
        private readonly TimeSpan _timeout;
        private readonly Action<EndPoint> _onClose;
        private readonly CancellationToken _serverCt;

        private DateTime _lastSeenUtc;
        private readonly EndPoint _ep;

        public ClientSession(
            TcpClient client,
            TimeSpan interval,
            TimeSpan timeout,
            Action<EndPoint> onClose,
            CancellationToken serverCt)
        {
            _client = client;
            _ns = client.GetStream();
            _reader = new StreamReader(_ns, new UTF8Encoding(false), detectEncodingFromByteOrderMarks: false, bufferSize: 4096, leaveOpen: true);
            _writer = new StreamWriter(_ns, new UTF8Encoding(false)) { AutoFlush = true };
            _interval = interval;
            _timeout = timeout;
            _onClose = onClose;
            _serverCt = serverCt;
            _lastSeenUtc = DateTime.UtcNow;
            _ep = _client.Client.RemoteEndPoint!;
        }

        public async Task RunAsync()
        {
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(_serverCt);
            var ct = cts.Token;

            var recv = ReceiveLoopAsync(ct);
            var hb = HeartbeatLoopAsync(ct);

            try
            {
                await Task.WhenAny(recv, hb).ConfigureAwait(false);
            }
            finally
            {
                cts.Cancel();
                try { await Task.WhenAll(Suppress(recv), Suppress(hb)); } catch { }
                await DisposeAsync();
                _onClose(_ep);
            }
        }

        private async Task ReceiveLoopAsync(CancellationToken ct)
        {
            try
            {
                while (!ct.IsCancellationRequested)
                {
                    // .NET 6+ : ReadLineAsync ã‚’ WaitAsync ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ã«
                    var line = await _reader.ReadLineAsync().WaitAsync(ct).ConfigureAwait(false);
                    if (line is null) break; // FIN å—ä¿¡ãªã©

                    _lastSeenUtc = DateTime.UtcNow;

                    if (line == "PING")
                    {
                        await _writer.WriteLineAsync("PONG").ConfigureAwait(false);
                        continue;
                    }

                    if (line == "PONG")
                    {
                        // å¿ƒæ‹å¿œç­”ã€‚ç‰¹ã«å‡¦ç†ä¸è¦
                        continue;
                    }

                    // ã‚¢ãƒ—ãƒªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šã“ã“ã§å‡¦ç†ã€‚ä¾‹ã¯ã‚¨ã‚³ãƒ¼
                    Console.WriteLine($"[{_ep}] {line}");
                    await _writer.WriteLineAsync($"ECHO: {line}").ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException) { }
            catch (IOException) { } // åˆ‡æ–­ç­‰
            catch (Exception ex)
            {
                Console.WriteLine($"[Recv {_ep}] {ex.Message}");
            }
        }

        private async Task HeartbeatLoopAsync(CancellationToken ct)
        {
            try
            {
                while (!ct.IsCancellationRequested)
                {
                    // é€ä¿¡ï¼ˆã‚µãƒ¼ãƒãƒ¼ä¸»å°ï¼‰
                    await _writer.WriteLineAsync("PING").ConfigureAwait(false);

                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆåˆ¤å®š
                    var until = DateTime.UtcNow + _timeout;
                    while (DateTime.UtcNow < until && !ct.IsCancellationRequested)
                    {
                        await Task.Delay(TimeSpan.FromMilliseconds(200), ct).ConfigureAwait(false);
                        if (DateTime.UtcNow - _lastSeenUtc < _timeout)
                            break;
                    }

                    if (DateTime.UtcNow - _lastSeenUtc >= _timeout)
                    {
                        Console.WriteLine($"[Heartbeat] timeout: {_ep}");
                        break; // åˆ‡æ–­
                    }

                    await Task.Delay(_interval, ct).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException) { }
            catch (IOException) { }
            catch (Exception ex)
            {
                Console.WriteLine($"[Heartbeat {_ep}] {ex.Message}");
            }
        }

        private static async Task Suppress(Task t)
        {
            try { await t; } catch { }
        }

        public async ValueTask DisposeAsync()
        {
            try { _writer.Dispose(); } catch { }
            try { _reader.Dispose(); } catch { }
            try { _ns.Dispose(); } catch { }
            try { _client.Close(); } catch { }
            await Task.CompletedTask;
        }
    }
}
```

## å®Ÿè¡Œç”¨ `Main`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        var server = new HeartbeatTcpServer(
            port: 5000,
            heartbeatInterval: TimeSpan.FromSeconds(10),
            heartbeatTimeout:  TimeSpan.FromSeconds(30));

        await server.StartAsync(cts.Token);

        Console.WriteLine("Server running. Ctrl+C to stop.");
        try { await Task.Delay(Timeout.Infinite, cts.Token); }
        catch (OperationCanceledException) { }

        await server.StopAsync();
        Console.WriteLine("Server stopped.");
    }
}
```

---

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆ`TcpClient` + è‡ªå‹•PONG + å†æ¥ç¶šï¼‰

* ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ `PING` ã‚’å—ã‘ãŸã‚‰å³ `PONG` ã‚’è¿”ã™
* ã‚¢ãƒ—ãƒªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ãã®ã¾ã¾è¡¨ç¤º
* åˆ‡æ–­æ¤œå‡ºã§ **è‡ªå‹•å†æ¥ç¶š**ï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®ç°¡æ˜“ç‰ˆï¼‰
* KeepAlive ã‚‚æœ‰åŠ¹åŒ–

```csharp
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class HeartbeatTcpClient : IAsyncDisposable
{
    private readonly string _host;
    private readonly int _port;
    private TcpClient? _client;
    private NetworkStream? _ns;
    private StreamReader? _reader;
    private StreamWriter? _writer;
    private readonly CancellationTokenSource _cts = new();

    public HeartbeatTcpClient(string host, int port)
    {
        _host = host;
        _port = port;
    }

    public async Task ConnectAsync()
    {
        _client = new TcpClient();
        await _client.ConnectAsync(_host, _port);
        _client.NoDelay = true;

        // OS ã® TCP KeepAliveï¼ˆä»»æ„ï¼‰
        TryEnableKeepAlive(_client, 30_000, 5_000);

        _ns = _client.GetStream();
        _reader = new StreamReader(_ns, new UTF8Encoding(false), false, 4096, leaveOpen: true);
        _writer = new StreamWriter(_ns, new UTF8Encoding(false)) { AutoFlush = true };

        Console.WriteLine($"Connected to {_host}:{_port}");
        _ = ReceiveLoopAsync(_cts.Token); // fire-and-forget
    }

    public async Task SendAsync(string line)
    {
        if (_writer is null) throw new InvalidOperationException("Not connected.");
        await _writer.WriteLineAsync(line);
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                var line = await _reader!.ReadLineAsync().WaitAsync(ct).ConfigureAwait(false);
                if (line is null) break;

                if (line == "PING")
                {
                    await _writer!.WriteLineAsync("PONG").ConfigureAwait(false);
                    continue;
                }

                Console.WriteLine($"[Server] {line}");
            }
        }
        catch (OperationCanceledException) { }
        catch (IOException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"[Client Receive] {ex.Message}");
        }

        await ReconnectLoopAsync();
    }

    private async Task ReconnectLoopAsync()
    {
        int delayMs = 1000;
        while (!_cts.IsCancellationRequested)
        {
            Console.WriteLine($"Reconnecting in {delayMs} ms...");
            try { await Task.Delay(delayMs, _cts.Token); } catch { return; }

            try
            {
                await ConnectAsync();
                Console.WriteLine("Reconnected.");
                return;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Reconnect failed: {ex.Message}");
                delayMs = Math.Min(delayMs * 2, 15_000); // ç°¡æ˜“æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
            }
        }
    }

    private static void TryEnableKeepAlive(TcpClient client, uint keepAliveTimeMs, uint keepAliveIntervalMs)
    {
        try
        {
            var s = client.Client;
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
            byte[] inOption = new byte[12];
            BitConverter.GetBytes(1u).CopyTo(inOption, 0);
            BitConverter.GetBytes(keepAliveTimeMs).CopyTo(inOption, 4);
            BitConverter.GetBytes(keepAliveIntervalMs).CopyTo(inOption, 8);
            s.IOControl(IOControlCode.KeepAliveValues, inOption, null);
        }
        catch { }
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        try { _writer?.Dispose(); } catch { }
        try { _reader?.Dispose(); } catch { }
        try { _ns?.Dispose(); } catch { }
        try { _client?.Close(); } catch { }
        await Task.CompletedTask;
    }
}
```

## ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè¡Œä¾‹

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        await using var client = new HeartbeatTcpClient("127.0.0.1", 5000);
        await client.ConnectAsync();

        Console.WriteLine("Type messages to send. Ctrl+C to exit.");
        while (true)
        {
            var line = Console.ReadLine();
            if (string.IsNullOrEmpty(line)) continue;
            await client.SendAsync(line);
        }
    }
}
```

---

## é‹ç”¨ãƒ¡ãƒ¢

* **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­è¨ˆ**ï¼š`heartbeatInterval` ã¯ 10â€“30 ç§’ã€`heartbeatTimeout` ã¯ 2ï½3 å›åˆ†ï¼ˆä¾‹ï¼š30â€“90 ç§’ï¼‰ã‚’ç›®å®‰ã«ã€‚
* **æ··é›‘ãƒ»é…å»¶è€æ€§**ï¼šã‚¢ãƒ—ãƒªå±¤å¿ƒæ‹ã¯é…å»¶ã§èª¤æ¤œçŸ¥ã—å¾—ã‚‹ãŸã‚ã€**2å›ä»¥ä¸Šã®ãƒŸã‚¹**ã§åˆ‡æ–­æ‰±ã„ã«ã—ã¦ã‚‚OKï¼ˆä¸Šè¨˜ã‚³ãƒ¼ãƒ‰ã¯æ™‚é–“ã§åˆ¤å®šï¼‰ã€‚
* **ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ‹¡å¼µ**ï¼šè¡ŒåŒºåˆ‡ã‚Šã§ååˆ†ã§ã™ãŒã€å¿…è¦ã«å¿œã˜ã¦é•·ã•ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹ï¼ˆLength-Prefixï¼‰ã‚„JSON/RPCã«æ‹¡å¼µã§ãã¾ã™ã€‚
* **è¿½åŠ ã®å³æ™‚åˆ¤å®š**ï¼šã‚µãƒ¼ãƒãƒ¼å´ã§ `Poll(0, Read) && Available == 0` ã‚’ä½µç”¨ã™ã‚‹ã¨ã€FIN å—ä¿¡æ™‚ã®å³æ™‚æ¤œå‡ºãŒå¯èƒ½ã€‚

---

å¿…è¦ãªã‚‰ã€ã“ã®å¿ƒæ‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ **ãƒã‚¤ãƒŠãƒªé•·ã•ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹æ–¹å¼** ã«ã—ãŸå …ç‰¢ç‰ˆï¼ˆNagle/ç²˜ç€å¯¾ç­–ãƒ»éƒ¨åˆ†èª­ã¿å–ã‚Šå¯¾å¿œï¼‰ã‚‚ç”¨æ„ã§ãã¾ã™ã€‚

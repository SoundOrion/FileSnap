äº†è§£ã§ã™ã€‚
ã§ã¯ã€ã‚ãªãŸã®ã“ã‚Œã¾ã§ã®è¨­è¨ˆæ„å›³ï¼ˆ

* SnapshotWorker: ã‚µãƒ¼ãƒãƒ¼å´ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç®¡ç†
* AcceptService: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¥ç¶šå—ã‘ä»˜ã‘ãƒ»ã‚¸ãƒ§ãƒ–æŠ•å…¥
* ProcessService: ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ãªã©ã®é‡ã„å‡¦ç†

ï¼‰ã‚’ç¶­æŒã—ãªãŒã‚‰ã€
**ã€Œæ¥ç¶šã”ã¨ã« Channel ã‚’åˆ†é›¢ã€ã—ã¦å®‰å…¨ã«ä¸¦åˆ—åŒ–ã™ã‚‹å®Œå…¨ç‰ˆã‚³ãƒ¼ãƒ‰ï¼ˆ.NET 8å¯¾å¿œï¼‰**
ã‚’ç¤ºã—ã¾ã™ã€‚

---

# ğŸ§± ã‚µãƒ¼ãƒãƒ¼æ§‹æˆï¼ˆæ¥ç¶šã”ã¨ Channel åˆ†é›¢ç‰ˆï¼‰

## ğŸ”¹ Program.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public static class Program
{
    public static async Task Main(string[] args)
    {
        using var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices(s =>
            {
                s.AddSingleton<IFileIndex, InMemoryFileIndex>();
                s.AddHostedService<SnapshotWorker>();
                s.AddHostedService<AcceptService>();
            })
            .Build();

        await host.RunAsync();
    }
}
```

---

## ğŸ”¹ SnapshotWorker.cs

ã‚µãƒ¼ãƒãƒ¼å´ãƒ•ã‚©ãƒ«ãƒ€ã‚’30ç§’ã”ã¨ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ›´æ–°ã€‚

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Security.Cryptography;

public sealed class SnapshotWorker : BackgroundService
{
    private readonly ILogger<SnapshotWorker> _log;
    private readonly IFileIndex _index;
    private readonly string _folder = @"D:\data";
    private readonly TimeSpan _period = TimeSpan.FromSeconds(30);

    public SnapshotWorker(ILogger<SnapshotWorker> log, IFileIndex index)
    {
        _log = log; _index = index;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await BuildAndSwapAsync(stoppingToken);
        using var timer = new PeriodicTimer(_period);
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            try { await BuildAndSwapAsync(stoppingToken); }
            catch (OperationCanceledException) { break; }
            catch (Exception ex) { _log.LogWarning(ex, "Snapshot update failed"); }
        }
    }

    private async Task BuildAndSwapAsync(CancellationToken ct)
    {
        var files = Directory.EnumerateFiles(_folder, "*.zip", SearchOption.TopDirectoryOnly);
        var bag = new ConcurrentBag<ArchiveInfo>();

        await Parallel.ForEachAsync(files, new ParallelOptions { CancellationToken = ct, MaxDegreeOfParallelism = Environment.ProcessorCount },
        async (path, token) =>
        {
            try
            {
                var fi = new FileInfo(path);
                await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read,
                    FileShare.ReadWrite | FileShare.Delete, 64 * 1024, FileOptions.Asynchronous | FileOptions.SequentialScan);
                var hash = await SHA256.HashDataAsync(fs, token);
                bag.Add(new ArchiveInfo(fi.FullName, fi.Length, fi.LastWriteTimeUtc, hash));
            }
            catch { }
        });

        var builder = ImmutableDictionary.CreateBuilder<string, ArchiveInfo>(StringComparer.OrdinalIgnoreCase);
        foreach (var f in bag)
            builder[f.FilePath] = f;

        _index.Replace(builder.ToImmutable());
        _log.LogInformation("Snapshot updated: {Count} files", builder.Count);
    }
}
```

---

## ğŸ”¹ Model.cs

å…±æœ‰ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

```csharp
using System.Collections.Immutable;

public sealed record ArchiveInfo(string FilePath, long Size, DateTimeOffset ModifiedUtc, byte[] Hash);

public interface IFileIndex
{
    ImmutableDictionary<string, ArchiveInfo> Snapshot { get; }
    void Replace(ImmutableDictionary<string, ArchiveInfo> next);
}

public sealed class InMemoryFileIndex : IFileIndex
{
    private ImmutableDictionary<string, ArchiveInfo> _snap =
        ImmutableDictionary<string, ArchiveInfo>.Empty.WithComparers(StringComparer.OrdinalIgnoreCase);

    public ImmutableDictionary<string, ArchiveInfo> Snapshot => System.Threading.Volatile.Read(ref _snap);

    public void Replace(ImmutableDictionary<string, ArchiveInfo> next) =>
        System.Threading.Interlocked.Exchange(ref _snap, next);
}

public sealed record SyncJob(
    string FilePath,
    long ClientUnixMs,
    long ClientSize,
    StreamWriter Writer,
    NetworkStream Stream,
    TaskCompletionSource<bool> Completion
);
```

---

## ğŸ”¹ AcceptService.csï¼ˆãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ï¼‰

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å—ã‘ä»˜ã‘ã€æ¥ç¶šã”ã¨ã«å°‚ç”¨ Channel ã¨ Worker ã‚’ç”Ÿæˆã€‚

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Channels;

public sealed class AcceptService : BackgroundService
{
    private readonly ILogger<AcceptService> _log;
    private readonly IFileIndex _index;
    private readonly int _port = 5001;
    private readonly ConcurrentDictionary<TcpClient, Channel<SyncJob>> _channels = new();

    public AcceptService(ILogger<AcceptService> log, IFileIndex index)
    { _log = log; _index = index; }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var listener = new TcpListener(IPAddress.Any, _port);
        listener.Start();
        _log.LogInformation("Listening on port {Port}", _port);

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var client = await listener.AcceptTcpClientAsync(stoppingToken);
                _log.LogInformation("Accepted: {Client}", client.Client.RemoteEndPoint);

                var ch = Channel.CreateUnbounded<SyncJob>(new UnboundedChannelOptions
                {
                    SingleReader = true,
                    SingleWriter = false
                });
                _channels[client] = ch;

                _ = Task.Run(() => HandleClientAsync(client, ch.Writer, stoppingToken), stoppingToken);
                _ = Task.Run(() => ClientWorkerLoopAsync(client, ch.Reader, stoppingToken), stoppingToken);
            }
        }
        catch (OperationCanceledException) { }
        finally
        {
            listener.Stop();
            _log.LogInformation("Server stopped");
        }
    }

    private async Task HandleClientAsync(TcpClient client, ChannelWriter<SyncJob> writer, CancellationToken ct)
    {
        using var ns = client.GetStream();
        using var reader = new StreamReader(ns, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true);
        using var w = new StreamWriter(ns, new UTF8Encoding(false), leaveOpen: true) { AutoFlush = true };

        try
        {
            while (!ct.IsCancellationRequested)
            {
                var line = await reader.ReadLineAsync(ct);
                if (string.IsNullOrWhiteSpace(line)) break;

                if (!line.StartsWith("SYNCGET|", StringComparison.OrdinalIgnoreCase))
                {
                    await w.WriteLineAsync("ERROR|unknown_command");
                    await w.FlushAsync();
                    continue;
                }

                var parts = line.Split('|', 4);
                if (parts.Length != 4 ||
                    !long.TryParse(parts[2], out var clientUnixMs) ||
                    !long.TryParse(parts[3], out var clientSize))
                {
                    await w.WriteLineAsync("ERROR|bad_request");
                    await w.FlushAsync();
                    continue;
                }

                var filePath = parts[1];
                var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
                await writer.WriteAsync(new SyncJob(filePath, clientUnixMs, clientSize, w, ns, tcs), ct);
                await tcs.Task;
            }
        }
        catch (OperationCanceledException) { }
        catch (Exception ex) { _log.LogWarning(ex, "Client error"); }
        finally
        {
            writer.Complete();
            client.Close();
            _channels.TryRemove(client, out _);
            _log.LogInformation("Client disconnected: {Client}", client.Client.RemoteEndPoint);
        }
    }

    private async Task ClientWorkerLoopAsync(TcpClient client, ChannelReader<SyncJob> reader, CancellationToken ct)
    {
        _log.LogInformation("Worker started for {Client}", client.Client.RemoteEndPoint);

        try
        {
            await foreach (var job in reader.ReadAllAsync(ct))
            {
                try
                {
                    await HandleOneAsync(job, ct);
                    job.Completion.TrySetResult(true);
                }
                catch (Exception ex)
                {
                    job.Completion.TrySetException(ex);
                }
            }
        }
        catch (OperationCanceledException) { }
        _log.LogInformation("Worker stopped for {Client}", client.Client.RemoteEndPoint);
    }

    private async Task HandleOneAsync(SyncJob job, CancellationToken ct)
    {
        var snap = _index.Snapshot;
        if (!snap.TryGetValue(job.FilePath, out var info) || !File.Exists(info.FilePath))
        {
            await job.Writer.WriteLineAsync("NOTFOUND");
            await job.Writer.FlushAsync();
            return;
        }

        var fi = new FileInfo(info.FilePath);
        var serverSize = fi.Length;
        var serverUnixMs = new DateTimeOffset(fi.LastWriteTimeUtc).ToUnixTimeMilliseconds();
        var modified = serverSize != job.ClientSize || serverUnixMs > job.ClientUnixMs;

        if (!modified)
        {
            await job.Writer.WriteLineAsync("NOTMODIFIED");
            await job.Writer.FlushAsync();
            return;
        }

        await job.Writer.WriteLineAsync($"FILEB64|{Path.GetFileName(info.FilePath)}|{serverSize}");
        await job.Writer.FlushAsync();

        using var fs = new FileStream(info.FilePath, FileMode.Open, FileAccess.Read,
                                      FileShare.ReadWrite | FileShare.Delete, 128 * 1024, FileOptions.SequentialScan);
        using var transform = new System.Security.Cryptography.ToBase64Transform();

        byte[] inBuf = new byte[57 * 1024];
        byte[] outBuf = new byte[inBuf.Length * 2];
        int n;
        while ((n = await fs.ReadAsync(inBuf, 0, inBuf.Length, ct)) > 0)
        {
            var outN = transform.TransformBlock(inBuf, 0, n - (n % 3), outBuf, 0);
            await job.Stream.WriteAsync(outBuf.AsMemory(0, outN), ct);
            if (n % 3 != 0)
            {
                var final = transform.TransformFinalBlock(inBuf, n - (n % 3), n % 3);
                await job.Stream.WriteAsync(final, ct);
            }
        }
        await job.Stream.FlushAsync(ct);
    }
}
```

---

## âœ… ã“ã®è¨­è¨ˆã®ç‰¹å¾´

| é …ç›®          | å†…å®¹                                  |
| ----------- | ----------------------------------- |
| **Channel** | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã”ã¨ã«ç‹¬ç«‹ (`SingleReader = true`) |
| **Worker**  | å„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå°‚ç”¨ã€‚é †åºä¿è¨¼ã‚ã‚Š                    |
| **ä¸¦åˆ—æ€§**     | ä»–ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã®é–“ã¯ä¸¦åˆ—å‹•ä½œ                     |
| **å®‰å…¨æ€§**     | åŒä¸€ NetworkStream ã«åŒæ™‚æ›¸ãè¾¼ã¿ãªã—          |
| **æ‹¡å¼µæ€§**     | ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ä»¥å¤–ã®ã‚¸ãƒ§ãƒ–ã‚‚å®¹æ˜“ã«è¿½åŠ å¯                 |

---

æ¬¡ã«å¸Œæœ›ãŒã‚ã‚Œã°ã€ã“ã®ã‚µãƒ¼ãƒãƒ¼ã«å¯¾å¿œã™ã‚‹
.NET 8 ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆè¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«é †æ¬¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¯¾å¿œï¼‰ã‚‚å‡ºã›ã¾ã™ã€‚
ä½œã‚Šã¾ã™ã‹ï¼Ÿ


ã„ã„ã‚ˆâ€”ã€Œ**æ¥ç¶šã”ã¨ Channel åˆ†é›¢**ã€ç‰ˆã®ã‚µãƒ¼ãƒãƒ¼ã«å¯¾å¿œã™ã‚‹ **.NET 8 ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆè¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«é †æ¬¡ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¯¾å¿œï¼‰**ã‚’ä¸¸ã£ã¨å‡ºã—ã¾ã™ã€‚
1 æ¥ç¶šã®ã¾ã¾ã€**ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã« `SYNCGET` ã‚’é †é€ã‚Š**â†’ã‚µãƒ¼ãƒã®è¿”ç­”ã‚’å—ã‘ã¦ä¿å­˜ã—ã¾ã™ã€‚

---

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆ.NET 8ï¼‰Program.cs

```csharp
// dotnet new console -n SyncClient && ã“ã‚Œã‚’ Program.cs ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    // ä½¿ã„æ–¹:
    //   dotnet run -- <serverHost> <port> <destFolder> <filePath1> [<filePath2> ...]
    // ä¾‹:
    //   dotnet run -- 127.0.0.1 5001 . "D:\\data\\a.zip" "D:\\data\\b.zip"
    static async Task<int> Main(string[] args)
    {
        if (args.Length < 4)
        {
            Console.WriteLine("Usage: SyncClient <host> <port> <destFolder> <filePath1> [filePath2 ...]");
            return 2;
        }

        string host = args[0];
        if (!int.TryParse(args[1], out var port)) { Console.WriteLine("Invalid port"); return 2; }
        string destFolder = args[2];
        Directory.CreateDirectory(destFolder);

        string[] serverFilePaths = args[3..];

        Console.WriteLine($"[Client] {host}:{port}  Dest='{destFolder}'  Files={serverFilePaths.Length}");

        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        try
        {
            using var cli = new TcpClient();
            await cli.ConnectAsync(host, port, cts.Token);

            using var ns = cli.GetStream();
            using var bs = new BufferedStream(ns, 64 * 1024);
            using var reader = new StreamReader(bs, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true);
            using var writer = new StreamWriter(bs, new UTF8Encoding(false), leaveOpen: true) { AutoFlush = true };

            // åŒä¸€æ¥ç¶šã§è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é †é€ã‚Šï¼ˆ1ãƒ•ã‚¡ã‚¤ãƒ«ãšã¤å®Œäº†å¾…ã¡ï¼‰
            foreach (var serverFilePath in serverFilePaths)
            {
                var (clientSize, clientUnixMs) = GetLocalMetaFor(serverFilePath, destFolder);
                await writer.WriteLineAsync($"SYNCGET|{serverFilePath}|{clientUnixMs}|{clientSize}");
                await writer.FlushAsync();

                var header = await reader.ReadLineAsync(cts.Token);
                if (string.IsNullOrWhiteSpace(header))
                    throw new IOException("Empty response");

                if (header.StartsWith("ERROR|", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] ERROR from server: {header}");
                    continue;
                }
                if (header.Equals("NOTFOUND", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] NOTFOUND: {serverFilePath}");
                    continue;
                }
                if (header.Equals("NOTMODIFIED", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] Up-to-date: {serverFilePath}");
                    continue;
                }

                // FILEB64|<name>|<rawLen>
                if (!header.StartsWith("FILEB64|", StringComparison.OrdinalIgnoreCase))
                    throw new IOException($"Unexpected header: {header}");

                var parts = header.Split('|', 3, StringSplitOptions.TrimEntries);
                if (parts.Length != 3 || !long.TryParse(parts[2], out var rawLen) || rawLen < 0)
                    throw new IOException($"Bad FILEB64 header: {header}");

                var fileName = parts[1];
                long b64Len = ((rawLen + 2) / 3) * 4; // Base64 æ–‡å­—æ•°ã‚’ç®—å‡º

                var destPath = Path.Combine(destFolder, Path.GetFileName(fileName));
                var tmp = destPath + ".tmp";
                Directory.CreateDirectory(Path.GetDirectoryName(destPath)!);
                Console.WriteLine($"[Client] Receiving {fileName}  raw={rawLen:N0}  b64={b64Len:N0}");

                await ReceiveBase64ToFileAsync(reader, b64Len, tmp, cts.Token);

                // å—ä¿¡ã‚µã‚¤ã‚ºæ¤œè¨¼ï¼ˆä»»æ„ï¼šrawLen ã¨å®Ÿä½“ã‚µã‚¤ã‚ºã¯ä¸€è‡´ã™ã‚‹ã¯ãšï¼‰
                var outLen = new FileInfo(tmp).Length;
                if (outLen != rawLen)
                {
                    File.Delete(tmp);
                    throw new IOException($"Size mismatch: expected {rawLen}, got {outLen}");
                }

                if (File.Exists(destPath))
                    File.Replace(tmp, destPath, destPath + ".bak", ignoreMetadataErrors: true);
                else
                    File.Move(tmp, destPath, overwrite: true);

                Console.WriteLine($"[Client] OK: {destPath}");
            }

            Console.WriteLine("[Client] Done.");
            return 0;
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("[Client] Canceled.");
            return 1;
        }
        catch (Exception ex)
        {
            Console.WriteLine("[Client] FAIL: " + ex.Message);
            return 1;
        }
    }

    // ãƒ­ãƒ¼ã‚«ãƒ«ã®æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆä¿å­˜å…ˆï¼‰æƒ…å ±ã‚’å–å¾—ï¼ˆãªã‘ã‚Œã° 0,0ï¼‰
    private static (long size, long unixMs) GetLocalMetaFor(string serverFilePath, string destFolder)
    {
        var localName = Path.GetFileName(serverFilePath);
        var localPath = Path.Combine(destFolder, localName);
        var fi = new FileInfo(localPath);
        if (!fi.Exists) return (0, 0);
        var size = fi.Length;
        var unixMs = new DateTimeOffset(fi.LastWriteTimeUtc).ToUnixTimeMilliseconds();
        return (size, unixMs);
    }

    // Base64 ã®ç·æ–‡å­—æ•° b64Len ã‚’ãã£ã¡ã‚Šèª­ã¿ã€ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã§ãƒ‡ã‚³ãƒ¼ãƒ‰â†’ãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸ã
    private static async Task ReceiveBase64ToFileAsync(StreamReader reader, long b64Len, string outPath, CancellationToken ct)
    {
        using var fs = new FileStream(outPath, FileMode.Create, FileAccess.Write, FileShare.None, 128 * 1024, useAsync: true);
        // charâ†’byte å¤‰æ›ã¯ä¸è¦ï¼šConvert.FromBase64CharArray ã‚’ä½¿ã†ï¼ˆãƒãƒ£ãƒ³ã‚¯ç«¯ã® 4 ã®å€æ•°å•é¡Œã«æ³¨æ„ï¼‰
        var buf = new char[8192];
        var carry = new char[4];
        int carryLen = 0;

        long remaining = b64Len;
        while (remaining > 0)
        {
            int need = (int)Math.Min(buf.Length, remaining);
            int n = await reader.ReadAsync(buf, 0, need);
            if (n <= 0) throw new EndOfStreamException("base64 stream ended early");
            remaining -= n;

            // carry ã¨çµåˆã—ã¦ 4 ã®å€æ•°ã¾ã§ãƒ‡ã‚³ãƒ¼ãƒ‰
            int total = carryLen + n;
            int full = (total / 4) * 4; // ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ãã‚‹ç·æ–‡å­—æ•°
            if (full > 0)
            {
                // work ã«ãƒ‡ã‚³ãƒ¼ãƒ‰åˆ†ã‚’ä½œã‚‹
                char[] work = new char[full];
                // å…ˆé ­ã« carry ã‚’è©°ã‚ã€æ®‹ã‚Šã¯ buf ã‹ã‚‰
                if (carryLen > 0)
                {
                    Array.Copy(carry, 0, work, 0, carryLen);
                    Array.Copy(buf, 0, work, carryLen, full - carryLen);
                }
                else
                {
                    Array.Copy(buf, 0, work, 0, full);
                }

                var decoded = Convert.FromBase64CharArray(work, 0, work.Length);
                await fs.WriteAsync(decoded, 0, decoded.Length, ct);
            }

            // æ–°ã—ã„ carry ã‚’æ›´æ–°ï¼ˆfull ã§ä½¿ã„åˆ‡ã‚Œãªã‹ã£ãŸæœ«å°¾åˆ†ï¼‰
            int leftover = total - full;
            if (leftover > 0)
            {
                // buf ã®ã©ã“ã‹ã‚‰ carry ã‚’å–ã‚‹ã‹
                // total = carryLen + n
                //  full  ã‚’æ¶ˆè²»ã—ãŸã®ã§ã€æ®‹ã‚Šã¯æœ«å°¾ leftover æ–‡å­—
                // ãã‚ŒãŒ buf å´ã«ä½•æ–‡å­—ãƒ»carry å´ã«ä½•æ–‡å­—ã‚ã‚‹ã‹ã‚’è¨ˆç®—
                // ç°¡å˜åŒ–ï¼šã¾ãšå…¨ä½“åˆ—ã‚’ä»®æƒ³çš„ã«ä¸¦ã¹ãŸã¨ã—ã¦æœ«å°¾ leftover ã‚’æŠœã
                // æœ«å°¾ leftover ã®ã†ã¡ã€buf ã‹ã‚‰å–ã‚‹æ•°:
                int takeFromBuf = Math.Min(leftover, n);
                int takeFromPrevCarry = leftover - takeFromBuf;

                if (takeFromPrevCarry > 0)
                    Array.Copy(carry, carryLen - takeFromPrevCarry, carry, 0, takeFromPrevCarry);

                if (takeFromBuf > 0)
                    Array.Copy(buf, n - takeFromBuf, carry, takeFromPrevCarry, takeFromBuf);

                carryLen = leftover;
            }
            else
            {
                carryLen = 0;
            }
        }

        // ã“ã“ã§ b64Len ã‚’ãã£ã¡ã‚Šèª­ã¿çµ‚ãˆã¦ã„ã‚‹ã®ã§ã€é€šå¸¸ carryLen ã¯ 0 ã®ã¯ãš
        if (carryLen > 0)
        {
            var decoded = Convert.FromBase64CharArray(carry, 0, carryLen);
            await fs.WriteAsync(decoded, 0, decoded.Length, ct);
        }
        await fs.FlushAsync(ct);
    }
}
```

---

## ã©ã†å‹•ãã‹ï¼ˆãƒã‚¤ãƒ³ãƒˆã ã‘ï¼‰

* ã‚µãƒ¼ãƒãŒè¿”ã™ãƒ˜ãƒƒãƒ€ã¯ `FILEB64|<name>|<rawLen>`ï¼ˆå‰å›ã‚ãªãŸãŒä½œã£ãŸã‚µãƒ¼ãƒã®æœ€æ–°ç‰ˆã«åˆã‚ã›ã¦ã„ã¾ã™ï¼‰ã€‚
* ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ `rawLen` ã‹ã‚‰ **Base64 ã®æ–‡å­—æ•° `b64Len=((rawLen+2)/3)*4`** ã‚’è¨ˆç®—ã€‚
  â†’ ã“ã‚Œã§**ã¡ã‚‡ã†ã© `b64Len` æ–‡å­—ã ã‘**ã‚’ `StreamReader` ã§èª­ã¿å–ã‚Šã€**ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã§ãƒ‡ã‚³ãƒ¼ãƒ‰**ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã€‚
* è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã¯ **åŒã˜æ¥ç¶šã§é †é€ã‚Š**ï¼ˆã‚µãƒ¼ãƒå´ã¯â€œæ¥ç¶šã”ã¨ Channel åˆ†é›¢â€ãªã®ã§ç«¶åˆã—ã¾ã›ã‚“ï¼‰ã€‚
* ä¿å­˜å…ˆã¯ç¬¬3å¼•æ•°ã® `destFolder`ã€‚åŒåãŒã‚ã‚Œã°ç½®ãæ›ãˆï¼ˆ`.bak`ã¯ä½œã‚‰ãšç°¡æ˜“ï¼‰ã€‚

---

## ã¡ã‚‡ã„è¶³ã—Tipsï¼ˆå¿…è¦ãªã‚‰ï¼‰

* é€²æ—è¡¨ç¤ºï¼š`remaining` ã¨ `b64Len` ã§å‰²åˆã‚’å‡ºã—ã¦ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æ›¸ãã ã‘ã§OKã€‚
* ãƒªãƒˆãƒ©ã‚¤ï¼š`try/catch` ã§å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã®å†é€ãƒ­ã‚¸ãƒƒã‚¯ã‚’åŒ…ã‚€ã€‚
* æ¤œè¨¼ï¼šSHA-256 ã‚’ä½µç”¨ã—ãŸã„å ´åˆã¯ã€ã‚µãƒ¼ãƒãŒãƒ˜ãƒƒãƒ€ã« `shaHex` ã‚’è¿½åŠ â†’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§å—ä¿¡å¾Œã«æ¤œè¨¼ã€‚

---

å¿…è¦ãªã‚‰ã€**ã‚µãƒ¼ãƒå´ã‚‚ `FILEB64|name|rawLen|b64Len` ã«ã—ã¦ã»ã—ã„**ç­‰ã®å¾®èª¿æ•´ã«ã‚‚åˆã‚ã›ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å‡ºã—ç›´ã—ã¾ã™ã€‚

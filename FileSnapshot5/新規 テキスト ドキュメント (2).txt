‰∫ÜËß£„Åß„Åô„ÄÇ
„Åß„ÅØ„ÄÅ„ÅÇ„Å™„Åü„ÅÆ„Åì„Çå„Åæ„Åß„ÅÆË®≠Ë®àÊÑèÂõ≥Ôºà

* SnapshotWorker: „Çµ„Éº„Éê„ÉºÂÅ¥„Éï„Ç°„Ç§„É´„ÅÆ„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„ÉàÁÆ°ÁêÜ
* AcceptService: „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÊé•Á∂öÂèó„Åë‰ªò„Åë„Éª„Ç∏„Éß„ÉñÊäïÂÖ•
* ProcessService: „Éï„Ç°„Ç§„É´ÈÄÅ‰ø°„Å™„Å©„ÅÆÈáç„ÅÑÂá¶ÁêÜ

Ôºâ„ÇíÁ∂≠ÊåÅ„Åó„Å™„Åå„Çâ„ÄÅ
**„ÄåÊé•Á∂ö„Åî„Å®„Å´ Channel „ÇíÂàÜÈõ¢„Äç„Åó„Å¶ÂÆâÂÖ®„Å´‰∏¶ÂàóÂåñ„Åô„ÇãÂÆåÂÖ®Áâà„Ç≥„Éº„ÉâÔºà.NET 8ÂØæÂøúÔºâ**
„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ

---

# üß± „Çµ„Éº„Éê„ÉºÊßãÊàêÔºàÊé•Á∂ö„Åî„Å® Channel ÂàÜÈõ¢ÁâàÔºâ

## üîπ Program.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public static class Program
{
    public static async Task Main(string[] args)
    {
        using var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices(s =>
            {
                s.AddSingleton<IFileIndex, InMemoryFileIndex>();
                s.AddHostedService<SnapshotWorker>();
                s.AddHostedService<AcceptService>();
            })
            .Build();

        await host.RunAsync();
    }
}
```

---

## üîπ SnapshotWorker.cs

„Çµ„Éº„Éê„ÉºÂÅ¥„Éï„Ç©„É´„ÉÄ„Çí30Áßí„Åî„Å®„Å´„Çπ„Ç≠„É£„É≥„Åó„Å¶„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„ÉàÊõ¥Êñ∞„ÄÇ

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Security.Cryptography;

public sealed class SnapshotWorker : BackgroundService
{
    private readonly ILogger<SnapshotWorker> _log;
    private readonly IFileIndex _index;
    private readonly string _folder = @"D:\data";
    private readonly TimeSpan _period = TimeSpan.FromSeconds(30);

    public SnapshotWorker(ILogger<SnapshotWorker> log, IFileIndex index)
    {
        _log = log; _index = index;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await BuildAndSwapAsync(stoppingToken);
        using var timer = new PeriodicTimer(_period);
        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            try { await BuildAndSwapAsync(stoppingToken); }
            catch (OperationCanceledException) { break; }
            catch (Exception ex) { _log.LogWarning(ex, "Snapshot update failed"); }
        }
    }

    private async Task BuildAndSwapAsync(CancellationToken ct)
    {
        var files = Directory.EnumerateFiles(_folder, "*.zip", SearchOption.TopDirectoryOnly);
        var bag = new ConcurrentBag<ArchiveInfo>();

        await Parallel.ForEachAsync(files, new ParallelOptions { CancellationToken = ct, MaxDegreeOfParallelism = Environment.ProcessorCount },
        async (path, token) =>
        {
            try
            {
                var fi = new FileInfo(path);
                await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read,
                    FileShare.ReadWrite | FileShare.Delete, 64 * 1024, FileOptions.Asynchronous | FileOptions.SequentialScan);
                var hash = await SHA256.HashDataAsync(fs, token);
                bag.Add(new ArchiveInfo(fi.FullName, fi.Length, fi.LastWriteTimeUtc, hash));
            }
            catch { }
        });

        var builder = ImmutableDictionary.CreateBuilder<string, ArchiveInfo>(StringComparer.OrdinalIgnoreCase);
        foreach (var f in bag)
            builder[f.FilePath] = f;

        _index.Replace(builder.ToImmutable());
        _log.LogInformation("Snapshot updated: {Count} files", builder.Count);
    }
}
```

---

## üîπ Model.cs

ÂÖ±Êúâ„Éá„Éº„Çø„É¢„Éá„É´

```csharp
using System.Collections.Immutable;

public sealed record ArchiveInfo(string FilePath, long Size, DateTimeOffset ModifiedUtc, byte[] Hash);

public interface IFileIndex
{
    ImmutableDictionary<string, ArchiveInfo> Snapshot { get; }
    void Replace(ImmutableDictionary<string, ArchiveInfo> next);
}

public sealed class InMemoryFileIndex : IFileIndex
{
    private ImmutableDictionary<string, ArchiveInfo> _snap =
        ImmutableDictionary<string, ArchiveInfo>.Empty.WithComparers(StringComparer.OrdinalIgnoreCase);

    public ImmutableDictionary<string, ArchiveInfo> Snapshot => System.Threading.Volatile.Read(ref _snap);

    public void Replace(ImmutableDictionary<string, ArchiveInfo> next) =>
        System.Threading.Interlocked.Exchange(ref _snap, next);
}

public sealed record SyncJob(
    string FilePath,
    long ClientUnixMs,
    long ClientSize,
    StreamWriter Writer,
    NetworkStream Stream,
    TaskCompletionSource<bool> Completion
);
```

---

## üîπ AcceptService.csÔºà„É°„Ç§„É≥„Çµ„Éº„Éì„ÇπÔºâ

„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÂèó„Åë‰ªò„Åë„ÄÅÊé•Á∂ö„Åî„Å®„Å´Â∞ÇÁî® Channel „Å® Worker „ÇíÁîüÊàê„ÄÇ

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Channels;

public sealed class AcceptService : BackgroundService
{
    private readonly ILogger<AcceptService> _log;
    private readonly IFileIndex _index;
    private readonly int _port = 5001;
    private readonly ConcurrentDictionary<TcpClient, Channel<SyncJob>> _channels = new();

    public AcceptService(ILogger<AcceptService> log, IFileIndex index)
    { _log = log; _index = index; }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var listener = new TcpListener(IPAddress.Any, _port);
        listener.Start();
        _log.LogInformation("Listening on port {Port}", _port);

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var client = await listener.AcceptTcpClientAsync(stoppingToken);
                _log.LogInformation("Accepted: {Client}", client.Client.RemoteEndPoint);

                var ch = Channel.CreateUnbounded<SyncJob>(new UnboundedChannelOptions
                {
                    SingleReader = true,
                    SingleWriter = false
                });
                _channels[client] = ch;

                _ = Task.Run(() => HandleClientAsync(client, ch.Writer, stoppingToken), stoppingToken);
                _ = Task.Run(() => ClientWorkerLoopAsync(client, ch.Reader, stoppingToken), stoppingToken);
            }
        }
        catch (OperationCanceledException) { }
        finally
        {
            listener.Stop();
            _log.LogInformation("Server stopped");
        }
    }

    private async Task HandleClientAsync(TcpClient client, ChannelWriter<SyncJob> writer, CancellationToken ct)
    {
        using var ns = client.GetStream();
        using var reader = new StreamReader(ns, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true);
        using var w = new StreamWriter(ns, new UTF8Encoding(false), leaveOpen: true) { AutoFlush = true };

        try
        {
            while (!ct.IsCancellationRequested)
            {
                var line = await reader.ReadLineAsync(ct);
                if (string.IsNullOrWhiteSpace(line)) break;

                if (!line.StartsWith("SYNCGET|", StringComparison.OrdinalIgnoreCase))
                {
                    await w.WriteLineAsync("ERROR|unknown_command");
                    await w.FlushAsync();
                    continue;
                }

                var parts = line.Split('|', 4);
                if (parts.Length != 4 ||
                    !long.TryParse(parts[2], out var clientUnixMs) ||
                    !long.TryParse(parts[3], out var clientSize))
                {
                    await w.WriteLineAsync("ERROR|bad_request");
                    await w.FlushAsync();
                    continue;
                }

                var filePath = parts[1];
                var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
                await writer.WriteAsync(new SyncJob(filePath, clientUnixMs, clientSize, w, ns, tcs), ct);
                await tcs.Task;
            }
        }
        catch (OperationCanceledException) { }
        catch (Exception ex) { _log.LogWarning(ex, "Client error"); }
        finally
        {
            writer.Complete();
            client.Close();
            _channels.TryRemove(client, out _);
            _log.LogInformation("Client disconnected: {Client}", client.Client.RemoteEndPoint);
        }
    }

    private async Task ClientWorkerLoopAsync(TcpClient client, ChannelReader<SyncJob> reader, CancellationToken ct)
    {
        _log.LogInformation("Worker started for {Client}", client.Client.RemoteEndPoint);

        try
        {
            await foreach (var job in reader.ReadAllAsync(ct))
            {
                try
                {
                    await HandleOneAsync(job, ct);
                    job.Completion.TrySetResult(true);
                }
                catch (Exception ex)
                {
                    job.Completion.TrySetException(ex);
                }
            }
        }
        catch (OperationCanceledException) { }
        _log.LogInformation("Worker stopped for {Client}", client.Client.RemoteEndPoint);
    }

    private async Task HandleOneAsync(SyncJob job, CancellationToken ct)
    {
        var snap = _index.Snapshot;
        if (!snap.TryGetValue(job.FilePath, out var info) || !File.Exists(info.FilePath))
        {
            await job.Writer.WriteLineAsync("NOTFOUND");
            await job.Writer.FlushAsync();
            return;
        }

        var fi = new FileInfo(info.FilePath);
        var serverSize = fi.Length;
        var serverUnixMs = new DateTimeOffset(fi.LastWriteTimeUtc).ToUnixTimeMilliseconds();
        var modified = serverSize != job.ClientSize || serverUnixMs > job.ClientUnixMs;

        if (!modified)
        {
            await job.Writer.WriteLineAsync("NOTMODIFIED");
            await job.Writer.FlushAsync();
            return;
        }

        await job.Writer.WriteLineAsync($"FILEB64|{Path.GetFileName(info.FilePath)}|{serverSize}");
        await job.Writer.FlushAsync();

        using var fs = new FileStream(info.FilePath, FileMode.Open, FileAccess.Read,
                                      FileShare.ReadWrite | FileShare.Delete, 128 * 1024, FileOptions.SequentialScan);
        using var transform = new System.Security.Cryptography.ToBase64Transform();

        byte[] inBuf = new byte[57 * 1024];
        byte[] outBuf = new byte[inBuf.Length * 2];
        int n;
        while ((n = await fs.ReadAsync(inBuf, 0, inBuf.Length, ct)) > 0)
        {
            var outN = transform.TransformBlock(inBuf, 0, n - (n % 3), outBuf, 0);
            await job.Stream.WriteAsync(outBuf.AsMemory(0, outN), ct);
            if (n % 3 != 0)
            {
                var final = transform.TransformFinalBlock(inBuf, n - (n % 3), n % 3);
                await job.Stream.WriteAsync(final, ct);
            }
        }
        await job.Stream.FlushAsync(ct);
    }
}
```

---

## ‚úÖ „Åì„ÅÆË®≠Ë®à„ÅÆÁâπÂæ¥

| È†ÖÁõÆ          | ÂÜÖÂÆπ                                  |
| ----------- | ----------------------------------- |
| **Channel** | „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Åî„Å®„Å´Áã¨Á´ã (`SingleReader = true`) |
| **Worker**  | ÂêÑ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂ∞ÇÁî®„ÄÇÈ†ÜÂ∫è‰øùË®º„ÅÇ„Çä                    |
| **‰∏¶ÂàóÊÄß**     | ‰ªñ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å®„ÅÆÈñì„ÅØ‰∏¶ÂàóÂãï‰Ωú                     |
| **ÂÆâÂÖ®ÊÄß**     | Âêå‰∏Ä NetworkStream „Å´ÂêåÊôÇÊõ∏„ÅçËæº„Åø„Å™„Åó          |
| **Êã°ÂºµÊÄß**     | „Éï„Ç°„Ç§„É´ÈÄÅ‰ø°‰ª•Â§ñ„ÅÆ„Ç∏„Éß„Éñ„ÇÇÂÆπÊòì„Å´ËøΩÂä†ÂèØ                 |

---

Ê¨°„Å´Â∏åÊúõ„Åå„ÅÇ„Çå„Å∞„ÄÅ„Åì„ÅÆ„Çµ„Éº„Éê„Éº„Å´ÂØæÂøú„Åô„Çã
.NET 8 „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÔºàË§áÊï∞„Éï„Ç°„Ç§„É´È†ÜÊ¨°„É™„ÇØ„Ç®„Çπ„ÉàÂØæÂøúÔºâ„ÇÇÂá∫„Åõ„Åæ„Åô„ÄÇ
‰Ωú„Çä„Åæ„Åô„ÅãÔºü


„ÅÑ„ÅÑ„Çà‚Äî„Äå**Êé•Á∂ö„Åî„Å® Channel ÂàÜÈõ¢**„ÄçÁâà„ÅÆ„Çµ„Éº„Éê„Éº„Å´ÂØæÂøú„Åô„Çã **.NET 8 „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÔºàË§áÊï∞„Éï„Ç°„Ç§„É´È†ÜÊ¨°„É™„ÇØ„Ç®„Çπ„ÉàÂØæÂøúÔºâ**„Çí‰∏∏„Å£„Å®Âá∫„Åó„Åæ„Åô„ÄÇ
1 Êé•Á∂ö„ÅÆ„Åæ„Åæ„ÄÅ**„Éï„Ç°„Ç§„É´„Åî„Å®„Å´ `SYNCGET` „ÇíÈ†ÜÈÄÅ„Çä**‚Üí„Çµ„Éº„Éê„ÅÆËøîÁ≠î„ÇíÂèó„Åë„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ

---

# „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÔºà.NET 8ÔºâProgram.cs

```csharp
// dotnet new console -n SyncClient && „Åì„Çå„Çí Program.cs „Å´Ë≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    // ‰Ωø„ÅÑÊñπ:
    //   dotnet run -- <serverHost> <port> <destFolder> <filePath1> [<filePath2> ...]
    // ‰æã:
    //   dotnet run -- 127.0.0.1 5001 . "D:\\data\\a.zip" "D:\\data\\b.zip"
    static async Task<int> Main(string[] args)
    {
        if (args.Length < 4)
        {
            Console.WriteLine("Usage: SyncClient <host> <port> <destFolder> <filePath1> [filePath2 ...]");
            return 2;
        }

        string host = args[0];
        if (!int.TryParse(args[1], out var port)) { Console.WriteLine("Invalid port"); return 2; }
        string destFolder = args[2];
        Directory.CreateDirectory(destFolder);

        string[] serverFilePaths = args[3..];

        Console.WriteLine($"[Client] {host}:{port}  Dest='{destFolder}'  Files={serverFilePaths.Length}");

        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        try
        {
            using var cli = new TcpClient();
            await cli.ConnectAsync(host, port, cts.Token);

            using var ns = cli.GetStream();
            using var bs = new BufferedStream(ns, 64 * 1024);
            using var reader = new StreamReader(bs, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true);
            using var writer = new StreamWriter(bs, new UTF8Encoding(false), leaveOpen: true) { AutoFlush = true };

            // Âêå‰∏ÄÊé•Á∂ö„ÅßË§áÊï∞„Éï„Ç°„Ç§„É´„ÇíÈ†ÜÈÄÅ„ÇäÔºà1„Éï„Ç°„Ç§„É´„Åö„Å§ÂÆå‰∫ÜÂæÖ„Å°Ôºâ
            foreach (var serverFilePath in serverFilePaths)
            {
                var (clientSize, clientUnixMs) = GetLocalMetaFor(serverFilePath, destFolder);
                await writer.WriteLineAsync($"SYNCGET|{serverFilePath}|{clientUnixMs}|{clientSize}");
                await writer.FlushAsync();

                var header = await reader.ReadLineAsync(cts.Token);
                if (string.IsNullOrWhiteSpace(header))
                    throw new IOException("Empty response");

                if (header.StartsWith("ERROR|", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] ERROR from server: {header}");
                    continue;
                }
                if (header.Equals("NOTFOUND", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] NOTFOUND: {serverFilePath}");
                    continue;
                }
                if (header.Equals("NOTMODIFIED", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine($"[Client] Up-to-date: {serverFilePath}");
                    continue;
                }

                // FILEB64|<name>|<rawLen>
                if (!header.StartsWith("FILEB64|", StringComparison.OrdinalIgnoreCase))
                    throw new IOException($"Unexpected header: {header}");

                var parts = header.Split('|', 3, StringSplitOptions.TrimEntries);
                if (parts.Length != 3 || !long.TryParse(parts[2], out var rawLen) || rawLen < 0)
                    throw new IOException($"Bad FILEB64 header: {header}");

                var fileName = parts[1];
                long b64Len = ((rawLen + 2) / 3) * 4; // Base64 ÊñáÂ≠óÊï∞„ÇíÁÆóÂá∫

                var destPath = Path.Combine(destFolder, Path.GetFileName(fileName));
                var tmp = destPath + ".tmp";
                Directory.CreateDirectory(Path.GetDirectoryName(destPath)!);
                Console.WriteLine($"[Client] Receiving {fileName}  raw={rawLen:N0}  b64={b64Len:N0}");

                await ReceiveBase64ToFileAsync(reader, b64Len, tmp, cts.Token);

                // Âèó‰ø°„Çµ„Ç§„Ç∫Ê§úË®ºÔºà‰ªªÊÑèÔºörawLen „Å®ÂÆü‰Ωì„Çµ„Ç§„Ç∫„ÅØ‰∏ÄËá¥„Åô„Çã„ÅØ„ÅöÔºâ
                var outLen = new FileInfo(tmp).Length;
                if (outLen != rawLen)
                {
                    File.Delete(tmp);
                    throw new IOException($"Size mismatch: expected {rawLen}, got {outLen}");
                }

                if (File.Exists(destPath))
                    File.Replace(tmp, destPath, destPath + ".bak", ignoreMetadataErrors: true);
                else
                    File.Move(tmp, destPath, overwrite: true);

                Console.WriteLine($"[Client] OK: {destPath}");
            }

            Console.WriteLine("[Client] Done.");
            return 0;
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("[Client] Canceled.");
            return 1;
        }
        catch (Exception ex)
        {
            Console.WriteLine("[Client] FAIL: " + ex.Message);
            return 1;
        }
    }

    // „É≠„Éº„Ç´„É´„ÅÆÊó¢Â≠ò„Éï„Ç°„Ç§„É´Ôºà‰øùÂ≠òÂÖàÔºâÊÉÖÂ†±„ÇíÂèñÂæóÔºà„Å™„Åë„Çå„Å∞ 0,0Ôºâ
    private static (long size, long unixMs) GetLocalMetaFor(string serverFilePath, string destFolder)
    {
        var localName = Path.GetFileName(serverFilePath);
        var localPath = Path.Combine(destFolder, localName);
        var fi = new FileInfo(localPath);
        if (!fi.Exists) return (0, 0);
        var size = fi.Length;
        var unixMs = new DateTimeOffset(fi.LastWriteTimeUtc).ToUnixTimeMilliseconds();
        return (size, unixMs);
    }

    // Base64 „ÅÆÁ∑èÊñáÂ≠óÊï∞ b64Len „Çí„Åç„Å£„Å°„ÇäË™≠„Åø„ÄÅ„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Åß„Éá„Ç≥„Éº„Éâ‚Üí„Éï„Ç°„Ç§„É´„Å∏Êõ∏„Åè
    private static async Task ReceiveBase64ToFileAsync(StreamReader reader, long b64Len, string outPath, CancellationToken ct)
    {
        using var fs = new FileStream(outPath, FileMode.Create, FileAccess.Write, FileShare.None, 128 * 1024, useAsync: true);
        // char‚Üíbyte Â§âÊèõ„ÅØ‰∏çË¶ÅÔºöConvert.FromBase64CharArray „Çí‰Ωø„ÅÜÔºà„ÉÅ„É£„É≥„ÇØÁ´Ø„ÅÆ 4 „ÅÆÂÄçÊï∞ÂïèÈ°å„Å´Ê≥®ÊÑèÔºâ
        var buf = new char[8192];
        var carry = new char[4];
        int carryLen = 0;

        long remaining = b64Len;
        while (remaining > 0)
        {
            int need = (int)Math.Min(buf.Length, remaining);
            int n = await reader.ReadAsync(buf, 0, need);
            if (n <= 0) throw new EndOfStreamException("base64 stream ended early");
            remaining -= n;

            // carry „Å®ÁµêÂêà„Åó„Å¶ 4 „ÅÆÂÄçÊï∞„Åæ„Åß„Éá„Ç≥„Éº„Éâ
            int total = carryLen + n;
            int full = (total / 4) * 4; // „Éá„Ç≥„Éº„Éâ„Åß„Åç„ÇãÁ∑èÊñáÂ≠óÊï∞
            if (full > 0)
            {
                // work „Å´„Éá„Ç≥„Éº„ÉâÂàÜ„Çí‰Ωú„Çã
                char[] work = new char[full];
                // ÂÖàÈ†≠„Å´ carry „ÇíË©∞„ÇÅ„ÄÅÊÆã„Çä„ÅØ buf „Åã„Çâ
                if (carryLen > 0)
                {
                    Array.Copy(carry, 0, work, 0, carryLen);
                    Array.Copy(buf, 0, work, carryLen, full - carryLen);
                }
                else
                {
                    Array.Copy(buf, 0, work, 0, full);
                }

                var decoded = Convert.FromBase64CharArray(work, 0, work.Length);
                await fs.WriteAsync(decoded, 0, decoded.Length, ct);
            }

            // Êñ∞„Åó„ÅÑ carry „ÇíÊõ¥Êñ∞Ôºàfull „Åß‰Ωø„ÅÑÂàá„Çå„Å™„Åã„Å£„ÅüÊú´Â∞æÂàÜÔºâ
            int leftover = total - full;
            if (leftover > 0)
            {
                // buf „ÅÆ„Å©„Åì„Åã„Çâ carry „ÇíÂèñ„Çã„Åã
                // total = carryLen + n
                //  full  „ÇíÊ∂àË≤ª„Åó„Åü„ÅÆ„Åß„ÄÅÊÆã„Çä„ÅØÊú´Â∞æ leftover ÊñáÂ≠ó
                // „Åù„Çå„Åå buf ÂÅ¥„Å´‰ΩïÊñáÂ≠ó„Éªcarry ÂÅ¥„Å´‰ΩïÊñáÂ≠ó„ÅÇ„Çã„Åã„ÇíË®àÁÆó
                // Á∞°ÂçòÂåñÔºö„Åæ„ÅöÂÖ®‰ΩìÂàó„Çí‰ªÆÊÉ≥ÁöÑ„Å´‰∏¶„Åπ„Åü„Å®„Åó„Å¶Êú´Â∞æ leftover „ÇíÊäú„Åè
                // Êú´Â∞æ leftover „ÅÆ„ÅÜ„Å°„ÄÅbuf „Åã„ÇâÂèñ„ÇãÊï∞:
                int takeFromBuf = Math.Min(leftover, n);
                int takeFromPrevCarry = leftover - takeFromBuf;

                if (takeFromPrevCarry > 0)
                    Array.Copy(carry, carryLen - takeFromPrevCarry, carry, 0, takeFromPrevCarry);

                if (takeFromBuf > 0)
                    Array.Copy(buf, n - takeFromBuf, carry, takeFromPrevCarry, takeFromBuf);

                carryLen = leftover;
            }
            else
            {
                carryLen = 0;
            }
        }

        // „Åì„Åì„Åß b64Len „Çí„Åç„Å£„Å°„ÇäË™≠„ÅøÁµÇ„Åà„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅÈÄöÂ∏∏ carryLen „ÅØ 0 „ÅÆ„ÅØ„Åö
        if (carryLen > 0)
        {
            var decoded = Convert.FromBase64CharArray(carry, 0, carryLen);
            await fs.WriteAsync(decoded, 0, decoded.Length, ct);
        }
        await fs.FlushAsync(ct);
    }
}
```

---

## „Å©„ÅÜÂãï„Åè„ÅãÔºà„Éù„Ç§„É≥„Éà„Å†„ÅëÔºâ

* „Çµ„Éº„Éê„ÅåËøî„Åô„Éò„ÉÉ„ÉÄ„ÅØ `FILEB64|<name>|<rawLen>`ÔºàÂâçÂõû„ÅÇ„Å™„Åü„Åå‰Ωú„Å£„Åü„Çµ„Éº„Éê„ÅÆÊúÄÊñ∞Áâà„Å´Âêà„Çè„Åõ„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ
* „ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅØ `rawLen` „Åã„Çâ **Base64 „ÅÆÊñáÂ≠óÊï∞ `b64Len=((rawLen+2)/3)*4`** „ÇíË®àÁÆó„ÄÇ
  ‚Üí „Åì„Çå„Åß**„Å°„Çá„ÅÜ„Å© `b64Len` ÊñáÂ≠ó„Å†„Åë**„Çí `StreamReader` „ÅßË™≠„ÅøÂèñ„Çä„ÄÅ**„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Åß„Éá„Ç≥„Éº„Éâ**„Åó„Å¶„Éï„Ç°„Ç§„É´„Å∏„ÄÇ
* Ë§áÊï∞„Éï„Ç°„Ç§„É´„ÅØ **Âêå„ÅòÊé•Á∂ö„ÅßÈ†ÜÈÄÅ„Çä**Ôºà„Çµ„Éº„ÉêÂÅ¥„ÅØ‚ÄúÊé•Á∂ö„Åî„Å® Channel ÂàÜÈõ¢‚Äù„Å™„ÅÆ„ÅßÁ´∂Âêà„Åó„Åæ„Åõ„ÇìÔºâ„ÄÇ
* ‰øùÂ≠òÂÖà„ÅØÁ¨¨3ÂºïÊï∞„ÅÆ `destFolder`„ÄÇÂêåÂêç„Åå„ÅÇ„Çå„Å∞ÁΩÆ„ÅçÊèõ„ÅàÔºà`.bak`„ÅØ‰Ωú„Çâ„ÅöÁ∞°ÊòìÔºâ„ÄÇ

---

## „Å°„Çá„ÅÑË∂≥„ÅóTipsÔºàÂøÖË¶Å„Å™„ÇâÔºâ

* ÈÄ≤ÊçóË°®Á§∫Ôºö`remaining` „Å® `b64Len` „ÅßÂâ≤Âêà„ÇíÂá∫„Åó„Å¶„Ç≥„É≥„ÇΩ„Éº„É´„Å´Êõ∏„Åè„Å†„Åë„ÅßOK„ÄÇ
* „É™„Éà„É©„Ç§Ôºö`try/catch` „ÅßÂÄãÂà•„Éï„Ç°„Ç§„É´„ÅÆÂÜçÈÄÅ„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂåÖ„ÇÄ„ÄÇ
* Ê§úË®ºÔºöSHA-256 „Çí‰ΩµÁî®„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Çµ„Éº„Éê„Åå„Éò„ÉÉ„ÉÄ„Å´ `shaHex` „ÇíËøΩÂä†‚Üí„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅßÂèó‰ø°Âæå„Å´Ê§úË®º„ÄÇ

---

ÂøÖË¶Å„Å™„Çâ„ÄÅ**„Çµ„Éº„ÉêÂÅ¥„ÇÇ `FILEB64|name|rawLen|b64Len` „Å´„Åó„Å¶„Åª„Åó„ÅÑ**Á≠â„ÅÆÂæÆË™øÊï¥„Å´„ÇÇÂêà„Çè„Åõ„Å¶„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÂá∫„ÅóÁõ¥„Åó„Åæ„Åô„ÄÇ

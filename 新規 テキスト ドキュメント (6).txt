ã„ã„ã§ã™ã‚ˆï¼ä¸»ã«ã“ã“ã‚’ç›´ã—ã¾ã—ãŸğŸ‘‡

* `IOControl(KeepAliveValues)` ã¸ã®å…¥åŠ›ã‚’ **ã‚¼ãƒ­ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³**ã§æ›¸ã‘ã‚‹ã‚ˆã†ã«
  `BinaryPrimitives.WriteInt32LittleEndian` ã‚’ä½¿ç”¨ï¼ˆ`BitConverter.GetBytes(...).CopyTo(...)` ã‚’æ’é™¤ï¼‰
* ã¤ã„ã§ã«å°ã•ãªå …ç‰¢åŒ–ï¼ˆå†æ¥ç¶šæ™‚ã®å¤ã„ã‚½ã‚±ãƒƒãƒˆç ´æ£„ã€`ConfigureAwait(false)` ã®å¾¹åº• ãªã©ï¼‰

---

# ã‚µãƒ¼ãƒãƒ¼ï¼ˆä¿®æ­£ç‰ˆï¼‰

```csharp
using System;
using System.Buffers.Binary; // â† è¿½åŠ 
using System.Collections.Concurrent;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class HeartbeatTcpServer : IAsyncDisposable
{
    private readonly TcpListener _listener;
    private readonly ConcurrentDictionary<EndPoint, ClientSession> _clients = new();
    private readonly TimeSpan _heartbeatInterval;
    private readonly TimeSpan _heartbeatTimeout;
    private CancellationTokenSource? _cts;
    private Task? _acceptTask;

    public HeartbeatTcpServer(
        int port,
        TimeSpan? heartbeatInterval = null,
        TimeSpan? heartbeatTimeout = null)
    {
        _listener = new TcpListener(IPAddress.Any, port);
        _heartbeatInterval = heartbeatInterval ?? TimeSpan.FromSeconds(10);
        _heartbeatTimeout = heartbeatTimeout ?? TimeSpan.FromSeconds(30);
    }

    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        _listener.Start();
        Console.WriteLine("Server started.");
        _acceptTask = AcceptLoopAsync(_cts.Token);
        await Task.CompletedTask;
    }

    public async Task StopAsync()
    {
        if (_cts is null) return;
        _cts.Cancel();
        _listener.Stop();

        foreach (var (_, s) in _clients)
        {
            try { await s.DisposeAsync(); } catch { /* ignore */ }
        }
        if (_acceptTask is not null)
        {
            try { await _acceptTask.ConfigureAwait(false); } catch { /* ignore */ }
        }
    }

    public async ValueTask DisposeAsync() => await StopAsync();

    private async Task AcceptLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                var client = await _listener.AcceptTcpClientAsync(ct).ConfigureAwait(false);
                client.NoDelay = true;

                // ä»»æ„ï¼šOSã®TCP KeepAliveï¼ˆæ—©æœŸæ¤œå‡ºãƒ»NATè¶Šãˆã®å®‰å®šåŒ–ï¼‰
                TryEnableKeepAlive(client, keepAliveTimeMs: 30_000, keepAliveIntervalMs: 5_000);

                var session = new ClientSession(client, _heartbeatInterval, _heartbeatTimeout, RemoveClient, ct);
                _clients[client.Client.RemoteEndPoint!] = session;
                Console.WriteLine($"Client connected: {client.Client.RemoteEndPoint}");
                _ = session.RunAsync(); // fire-and-forget
            }
        }
        catch (OperationCanceledException) { }
        catch (ObjectDisposedException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"[AcceptLoop] {ex}");
        }
    }

    private void RemoveClient(EndPoint ep)
    {
        _clients.TryRemove(ep, out _);
        Console.WriteLine($"Client removed: {ep}");
    }

    private static void TryEnableKeepAlive(TcpClient client, uint keepAliveTimeMs, uint keepAliveIntervalMs)
    {
        try
        {
            var s = client.Client;
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);

            // Windows ã®è©³ç´°è¨­å®šï¼ˆ12ãƒã‚¤ãƒˆå›ºå®š: [on(4)][time(4)][interval(4)] little-endianï¼‰
            byte[] inOption = new byte[12];
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(0, 4), 1); // æœ‰åŠ¹åŒ–
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(4, 4), unchecked((int)keepAliveTimeMs));
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(8, 4), unchecked((int)keepAliveIntervalMs));

            s.IOControl(IOControlCode.KeepAliveValues, inOption, null);
        }
        catch
        {
            // æœªå¯¾å¿œOSã¯é»™ã£ã¦ã‚¹ã‚­ãƒƒãƒ—
        }
    }

    private sealed class ClientSession : IAsyncDisposable
    {
        private readonly TcpClient _client;
        private readonly NetworkStream _ns;
        private readonly StreamReader _reader;
        private readonly StreamWriter _writer;
        private readonly TimeSpan _interval;
        private readonly TimeSpan _timeout;
        private readonly Action<EndPoint> _onClose;
        private readonly CancellationToken _serverCt;

        private DateTime _lastSeenUtc;
        private readonly EndPoint _ep;

        public ClientSession(
            TcpClient client,
            TimeSpan interval,
            TimeSpan timeout,
            Action<EndPoint> onClose,
            CancellationToken serverCt)
        {
            _client = client;
            _ns = client.GetStream();
            _reader = new StreamReader(_ns, new UTF8Encoding(false), detectEncodingFromByteOrderMarks: false, bufferSize: 4096, leaveOpen: true);
            _writer = new StreamWriter(_ns, new UTF8Encoding(false)) { AutoFlush = true };
            _interval = interval;
            _timeout = timeout;
            _onClose = onClose;
            _serverCt = serverCt;
            _lastSeenUtc = DateTime.UtcNow;
            _ep = _client.Client.RemoteEndPoint!;
        }

        public async Task RunAsync()
        {
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(_serverCt);
            var ct = cts.Token;

            var recv = ReceiveLoopAsync(ct);
            var hb = HeartbeatLoopAsync(ct);

            try
            {
                await Task.WhenAny(recv, hb).ConfigureAwait(false);
            }
            finally
            {
                cts.Cancel();
                try { await Task.WhenAll(Suppress(recv), Suppress(hb)).ConfigureAwait(false); } catch { }
                await DisposeAsync();
                _onClose(_ep);
            }
        }

        private async Task ReceiveLoopAsync(CancellationToken ct)
        {
            try
            {
                while (!ct.IsCancellationRequested)
                {
                    // .NET 6+ : ReadLineAsync ã‚’ WaitAsync ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ã«
                    var line = await _reader.ReadLineAsync().WaitAsync(ct).ConfigureAwait(false);
                    if (line is null) break; // FIN å—ä¿¡ãªã©

                    _lastSeenUtc = DateTime.UtcNow;

                    if (line == "PING")
                    {
                        await _writer.WriteLineAsync("PONG").ConfigureAwait(false);
                        continue;
                    }

                    if (line == "PONG")
                    {
                        // å¿ƒæ‹å¿œç­”ã€‚ç‰¹ã«å‡¦ç†ä¸è¦
                        continue;
                    }

                    // ã‚¢ãƒ—ãƒªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šã“ã“ã§å‡¦ç†ã€‚ä¾‹ã¯ã‚¨ã‚³ãƒ¼
                    Console.WriteLine($"[{_ep}] {line}");
                    await _writer.WriteLineAsync($"ECHO: {line}").ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException) { }
            catch (IOException) { } // åˆ‡æ–­ç­‰
            catch (Exception ex)
            {
                Console.WriteLine($"[Recv {_ep}] {ex.Message}");
            }
        }

        private async Task HeartbeatLoopAsync(CancellationToken ct)
        {
            try
            {
                while (!ct.IsCancellationRequested)
                {
                    // é€ä¿¡ï¼ˆã‚µãƒ¼ãƒãƒ¼ä¸»å°ï¼‰
                    await _writer.WriteLineAsync("PING").ConfigureAwait(false);

                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆåˆ¤å®š
                    var until = DateTime.UtcNow + _timeout;
                    while (DateTime.UtcNow < until && !ct.IsCancellationRequested)
                    {
                        await Task.Delay(TimeSpan.FromMilliseconds(200), ct).ConfigureAwait(false);
                        if (DateTime.UtcNow - _lastSeenUtc < _timeout)
                            break;
                    }

                    if (DateTime.UtcNow - _lastSeenUtc >= _timeout)
                    {
                        Console.WriteLine($"[Heartbeat] timeout: {_ep}");
                        break; // åˆ‡æ–­
                    }

                    await Task.Delay(_interval, ct).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException) { }
            catch (IOException) { }
            catch (Exception ex)
            {
                Console.WriteLine($"[Heartbeat {_ep}] {ex.Message}");
            }
        }

        private static async Task Suppress(Task t)
        {
            try { await t.ConfigureAwait(false); } catch { }
        }

        public async ValueTask DisposeAsync()
        {
            try { _writer.Dispose(); } catch { }
            try { _reader.Dispose(); } catch { }
            try { _ns.Dispose(); } catch { }
            try { _client.Close(); } catch { }
            await Task.CompletedTask;
        }
    }
}
```

## å®Ÿè¡Œç”¨ Mainï¼ˆãã®ã¾ã¾ï¼‰

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        var server = new HeartbeatTcpServer(
            port: 5000,
            heartbeatInterval: TimeSpan.FromSeconds(10),
            heartbeatTimeout:  TimeSpan.FromSeconds(30));

        await server.StartAsync(cts.Token);

        Console.WriteLine("Server running. Ctrl+C to stop.");
        try { await Task.Delay(Timeout.Infinite, cts.Token); }
        catch (OperationCanceledException) { }

        await server.StopAsync();
        Console.WriteLine("Server stopped.");
    }
}
```

---

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆä¿®æ­£ç‰ˆï¼‰

```csharp
using System;
using System.Buffers.Binary; // â† è¿½åŠ 
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class HeartbeatTcpClient : IAsyncDisposable
{
    private readonly string _host;
    private readonly int _port;
    private TcpClient? _client;
    private NetworkStream? _ns;
    private StreamReader? _reader;
    private StreamWriter? _writer;
    private readonly CancellationTokenSource _cts = new();

    public HeartbeatTcpClient(string host, int port)
    {
        _host = host;
        _port = port;
    }

    public async Task ConnectAsync()
    {
        // æ—¢å­˜æ¥ç¶šãŒã‚ã‚Œã°ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆå†æ¥ç¶šæ™‚ã®ãŸã‚ï¼‰
        await CleanupAsync();

        _client = new TcpClient();
        await _client.ConnectAsync(_host, _port).ConfigureAwait(false);
        _client.NoDelay = true;

        // OS ã® TCP KeepAliveï¼ˆä»»æ„ï¼‰
        TryEnableKeepAlive(_client, 30_000, 5_000);

        _ns = _client.GetStream();
        _reader = new StreamReader(_ns, new UTF8Encoding(false), detectEncodingFromByteOrderMarks: false, bufferSize: 4096, leaveOpen: true);
        _writer = new StreamWriter(_ns, new UTF8Encoding(false)) { AutoFlush = true };

        Console.WriteLine($"Connected to {_host}:{_port}");
        _ = ReceiveLoopAsync(_cts.Token); // fire-and-forget
    }

    public async Task SendAsync(string line)
    {
        if (_writer is null) throw new InvalidOperationException("Not connected.");
        await _writer.WriteLineAsync(line).ConfigureAwait(false);
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested)
            {
                var line = await _reader!.ReadLineAsync().WaitAsync(ct).ConfigureAwait(false);
                if (line is null) break;

                if (line == "PING")
                {
                    await _writer!.WriteLineAsync("PONG").ConfigureAwait(false);
                    continue;
                }

                Console.WriteLine($"[Server] {line}");
            }
        }
        catch (OperationCanceledException) { }
        catch (IOException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"[Client Receive] {ex.Message}");
        }

        await ReconnectLoopAsync().ConfigureAwait(false);
    }

    private async Task ReconnectLoopAsync()
    {
        int delayMs = 1000;
        while (!_cts.IsCancellationRequested)
        {
            Console.WriteLine($"Reconnecting in {delayMs} ms...");
            try { await Task.Delay(delayMs, _cts.Token).ConfigureAwait(false); } catch { return; }

            try
            {
                await ConnectAsync().ConfigureAwait(false);
                Console.WriteLine("Reconnected.");
                return;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Reconnect failed: {ex.Message}");
                delayMs = Math.Min(delayMs * 2, 15_000); // ç°¡æ˜“æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
            }
        }
    }

    private static void TryEnableKeepAlive(TcpClient client, uint keepAliveTimeMs, uint keepAliveIntervalMs)
    {
        try
        {
            var s = client.Client;
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);

            byte[] inOption = new byte[12];
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(0, 4), 1);
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(4, 4), unchecked((int)keepAliveTimeMs));
            BinaryPrimitives.WriteInt32LittleEndian(inOption.AsSpan(8, 4), unchecked((int)keepAliveIntervalMs));
            s.IOControl(IOControlCode.KeepAliveValues, inOption, null);
        }
        catch { }
    }

    private async Task CleanupAsync()
    {
        try { _writer?.Dispose(); } catch { }
        try { _reader?.Dispose(); } catch { }
        try { _ns?.Dispose(); } catch { }
        try { _client?.Close(); } catch { }
        await Task.CompletedTask;
        _writer = null; _reader = null; _ns = null; _client = null;
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        await CleanupAsync();
    }
}
```

## ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè¡Œä¾‹ï¼ˆãã®ã¾ã¾ï¼‰

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        await using var client = new HeartbeatTcpClient("127.0.0.1", 5000);
        await client.ConnectAsync();

        Console.WriteLine("Type messages to send. Ctrl+C to exit.");
        while (true)
        {
            var line = Console.ReadLine();
            if (string.IsNullOrEmpty(line)) continue;
            await client.SendAsync(line);
        }
    }
}
```

---

å¿…è¦ã‚ã‚Œã°ã€**`BinaryPrimitives` ã‚’ä½¿ã£ãŸãƒ˜ãƒ«ãƒ‘ãƒ¼æ‹¡å¼µãƒ¡ã‚½ãƒƒãƒ‰**ï¼ˆ`SetKeepAlive`ï¼‰ã«åˆ‡ã‚Šå‡ºã—ãŸç‰ˆã‚‚å‡ºã—ã¾ã™ã€‚

äº†è§£ã€‚ã„ã¾ä½œã£ã¦ã„ã‚‹ã‚‚ã®ã‚’ã€Œä¸€æšã§ã‚ã‹ã‚‹ã€å½¢ã§æ•´ç†ã—ã¾ã™ã€‚

# ã“ã‚Œã¯ä½•ï¼Ÿ

**TCP å¸¸æ™‚æ¥ç¶šã®æ­»æ´»ç›£è¦–ã¤ãé€šä¿¡åŸºç›¤**ã€‚
ã‚µãƒ¼ãƒãƒ¼ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒ **è¡ŒåŒºåˆ‡ã‚Šãƒ†ã‚­ã‚¹ãƒˆ**ã§ã‚„ã‚Šå–ã‚Šã—ã¤ã¤ã€
**ã‚¢ãƒ—ãƒªå±¤ã®å¿ƒæ‹ï¼ˆPING/PONGï¼‰** ã¨ **OSã®TCP KeepAlive** ã®äºŒæ®µæ§‹ãˆã§
ã€Œç›¸æ‰‹ãŒç”Ÿãã¦ã„ã‚‹ã‹ã€ã‚’è‡ªå‹•åˆ¤å®šãƒ»è‡ªå‹•å¾©æ—§ã—ã¾ã™ã€‚

# æ§‹æˆ

* **ã‚µãƒ¼ãƒãƒ¼ï¼ˆHeartbeatTcpServerï¼‰**

  * `TcpListener` ã§æ¥ç¶šå—ä»˜
  * æ¥ç¶šã”ã¨ã« `ClientSession` ã‚’ä½œæˆ
  * **å®šæœŸçš„ã« `PING\n` ã‚’é€ä¿¡**
  * å—ä¿¡ãƒ«ãƒ¼ãƒ—ã§ `PONG` ã‚„é€šå¸¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†
  * **`heartbeatTimeout` ã‚’è¶…ãˆã¦å¿œç­”ãŒãªã‘ã‚Œã°åˆ‡æ–­**
  * ï¼ˆä»»æ„ï¼‰**TCP KeepAlive** ã‚’æœ‰åŠ¹åŒ–ï¼ˆWindowsã§è©³ç´°å€¤ã‚’è¨­å®šï¼‰

* **ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆHeartbeatTcpClientï¼‰**

  * `TcpClient` ã§ã‚µãƒ¼ãƒãƒ¼ã¸æ¥ç¶š
  * **`PING` ã‚’å—ä¿¡ã—ãŸã‚‰å³ `PONG` ã‚’è¿”ä¿¡**
  * é€šå¸¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ãã®ã¾ã¾è¡¨ç¤ºï¼ã‚¢ãƒ—ãƒªå‡¦ç†
  * åˆ‡æ–­ãƒ»ã‚¨ãƒ©ãƒ¼æ™‚ã¯ **æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§è‡ªå‹•å†æ¥ç¶š**
  * ï¼ˆä»»æ„ï¼‰**TCP KeepAlive** ã‚’æœ‰åŠ¹åŒ–

# ä½•ãŒå¬‰ã—ã„ï¼Ÿ

* **å³å¿œæ€§Ã—ç¢ºå®Ÿæ€§**

  * ã‚¢ãƒ—ãƒªå±¤å¿ƒæ‹ â†’ æ•°ç§’ã€œåæ•°ç§’ã§ç„¡å¿œç­”ã‚’æ¤œå‡º
  * TCP KeepAlive â†’ ç•°å¸¸çµ‚äº†ã‚„NATè¶Šãˆã§ã®â€œå¹½éœŠæ¥ç¶šâ€æ¤œçŸ¥ã‚’OSãŒè£œåŠ©
* **å …ç‰¢**

  * `async/await` ãƒ™ãƒ¼ã‚¹ã§ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãªã—
  * å†æ¥ç¶šãƒ«ãƒ¼ãƒ—ã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–­ã‹ã‚‰è‡ªå‹•å¾©å¸°
* **è»½é‡**

  * ãƒ†ã‚­ã‚¹ãƒˆè¡Œãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆ`\n`ï¼‰
  * KeepAliveè¨­å®šã¯**ã‚¼ãƒ­ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³**ï¼ˆ`BinaryPrimitives`ï¼‰

# å‹•ä½œãƒ•ãƒ­ãƒ¼ï¼ˆã–ã£ãã‚Šï¼‰

1. ã‚µãƒ¼ãƒãƒ¼ï¼šæ¥ç¶šã‚’å—ã‘ãŸã‚‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ç”Ÿæˆã€å—ä¿¡ãƒ«ãƒ¼ãƒ—ã¨å¿ƒæ‹ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
2. å¿ƒæ‹ãƒ«ãƒ¼ãƒ—ï¼š`interval` ã”ã¨ã« `PING` é€ä¿¡
3. å—ä¿¡ãƒ«ãƒ¼ãƒ—ï¼š`PONG` ã‚„é€šå¸¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ â†’ **æœ€çµ‚å¿œç­”æ™‚åˆ»ã‚’æ›´æ–°**
4. **`timeout` è¶…é**ï¼ˆæœ€çµ‚å¿œç­”ãªã—ï¼‰â†’ ã‚µãƒ¼ãƒãƒ¼ãŒåˆ‡æ–­ï¼†ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
5. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼šåˆ‡æ–­æ¤œçŸ¥ â†’ **å†æ¥ç¶š**ï¼ˆ1sâ†’2sâ†’â€¦æœ€å¤§15sã®ãƒãƒƒã‚¯ã‚ªãƒ•ï¼‰

# è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆç›®å®‰ï¼‰

* ã‚µãƒ¼ãƒãƒ¼

  * `heartbeatInterval`: 10â€“30 ç§’
  * `heartbeatTimeout`: `interval` ã® 2ï½3 å€ï¼ˆä¾‹ï¼š30â€“90 ç§’ï¼‰
* KeepAliveï¼ˆWindowsä¾‹ï¼‰

  * `keepAliveTimeMs`: 30,000
  * `keepAliveIntervalMs`: 5,000
    â€»ç”¨é€”ã«ã‚ˆã‚Šèª¿æ•´ï¼ˆLANã§é€Ÿãã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã§ã‚„ã‚„é•·ã‚ï¼‰

# ä½¿ã„ã©ã“ã‚

* ãƒãƒ£ãƒƒãƒˆãƒ»é€šçŸ¥ãƒ»ã‚²ãƒ¼ãƒ ãªã©ã®**å¸¸æ™‚æ¥ç¶š**ã‚¢ãƒ—ãƒª
* **ã‚¢ã‚¤ãƒ‰ãƒ«ãŒé•·ã„**æ¥ç¶šï¼ˆNATã‚„FWã§åˆ‡ã‚‰ã‚ŒãŒã¡ï¼‰
* **ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒä¸å®‰å®š**ï¼ˆãƒ¢ãƒã‚¤ãƒ«/ç„¡ç·šï¼‰ã®ç’°å¢ƒ

# æ³¨æ„ç‚¹ãƒ»æ‹¡å¼µ

* å¿ƒæ‹ã¯**èª¤æ¤œçŸ¥é˜²æ­¢**ã®ãŸã‚ã€**2é€£ç¶šãƒŸã‚¹åˆ¤å®š**ã‚„**Jitter**ã‚’å…¥ã‚Œã‚‹æ‹¡å¼µã‚‚å¯
* ãƒ†ã‚­ã‚¹ãƒˆã§ã¯ãªã**é•·ã•ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹ã®ãƒã‚¤ãƒŠãƒª**ã«ã™ã‚‹ã¨ãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°ãŒã‚ˆã‚Šå …ç‰¢
* ãƒ¡ãƒˆãƒªã‚¯ã‚¹ï¼ˆRTTã€å¤±æ•—å›æ•°ï¼‰ã‚’è¨ˆæ¸¬ã—ã¦ãƒ­ã‚°/ç›£è¦–ã«å‡ºã™ã¨é‹ç”¨ã—ã‚„ã™ã„

---

ã“ã®ã¾ã¾ã§ã‚‚å®Ÿç”¨ãƒ¬ãƒ™ãƒ«ã§ã™ãŒã€**é•·ã•ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹æ–¹å¼**ã‚„**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ«ãƒ¼ã‚¿ãƒ¼/ãƒãƒ³ãƒ‰ãƒ©**ã‚’è¼‰ã›ãŸæ‹¡å¼µç‰ˆã‚‚ä½œã‚Œã¾ã™ã€‚å¿…è¦ãªã‚‰ç¶šã‘ã¦å‡ºã—ã¾ã™ï¼

ã„ã„æµã‚Œã§ã™ã€‚ãã®ç†è§£ã§OKã€‚
ã“ã“ã‹ã‚‰ã¯ **ã€Œã‚µãƒ¼ãƒãƒ¼å†…ã®â€œã‚µãƒ¼ãƒ“ã‚¹ï¼ˆDBã‚„å¤–éƒ¨APIãªã©ï¼‰ãŒç”Ÿãã¦ã„ã‚‹ã‹ã€** ã‚’â€œã‚¢ãƒ—ãƒªå±¤ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯â€ã§ç¢ºã‹ã‚ã‚‹æ‹¡å¼µã‚’å…¥ã‚Œã¾ã™ã€‚

# æ–¹é‡ï¼ˆã‚µã‚¯ãƒƒã¨è¦ç´„ï¼‰

* ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’æ‹¡å¼µã—ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒ **`HEALTH?`** ã‚’é€ã‚‹ã¨ã‚µãƒ¼ãƒãƒ¼ãŒ
  **ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒã‚§ãƒƒã‚¯çµæœã‚’é›†ç´„ã—ã¦è¿”ã™** å½¢ã«ã—ã¾ã™ã€‚
* è¿”ç­”ã¯1è¡ŒJSONï¼ˆè¡ŒåŒºåˆ‡ã‚Šãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ç¶­æŒï¼‰ã€‚
  ä¾‹ï¼š`HEALTH {"overall":"OK","checks":[{"name":"db","ok":true,"ms":12}...]}`

---

# 1) ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®æœ€å°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¨å®Ÿè£…ä¾‹

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

public sealed record HealthItem(string Name, bool Ok, long ElapsedMs, string? Message = null);
public sealed record HealthReport(string Overall, IReadOnlyList<HealthItem> Checks);

public interface IHealthCheck
{
    string Name { get; }
    Task<HealthItem> CheckAsync(CancellationToken ct);
}

public sealed class FuncHealthCheck : IHealthCheck
{
    private readonly Func<CancellationToken, Task> _probe;
    public string Name { get; }

    public FuncHealthCheck(string name, Func<CancellationToken, Task> probe)
    {
        Name = name; _probe = probe;
    }

    public async Task<HealthItem> CheckAsync(CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        try
        {
            await _probe(ct);
            sw.Stop();
            return new HealthItem(Name, ok: true, sw.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            sw.Stop();
            return new HealthItem(Name, ok: false, sw.ElapsedMilliseconds, ex.Message);
        }
    }
}

public sealed class HealthAggregator
{
    private readonly List<IHealthCheck> _checks = new();

    public HealthAggregator Add(IHealthCheck check)
    {
        _checks.Add(check);
        return this;
    }

    public async Task<HealthReport> RunAsync(TimeSpan perCheckTimeout, CancellationToken ct)
    {
        var items = new List<HealthItem>(_checks.Count);
        foreach (var c in _checks)
        {
            try
            {
                using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
                cts.CancelAfter(perCheckTimeout);
                items.Add(await c.CheckAsync(cts.Token));
            }
            catch (Exception ex)
            {
                items.Add(new HealthItem(c.Name, false, 0, $"runner: {ex.Message}"));
            }
        }

        bool allOk = items.TrueForAll(i => i.Ok);
        return new HealthReport(allOk ? "OK" : "FAIL", items);
    }
}
```

### ä¾‹ï¼šãƒã‚§ãƒƒã‚¯ã®ä¸­èº«ï¼ˆç”¨é€”åˆ¥ã«å·®ã—æ›¿ãˆã¦ãã ã•ã„ï¼‰

```csharp
// 1) å¤–éƒ¨HTTPã®ç–é€šç¢ºèªï¼ˆ200ç•ªå°ãªã‚‰OKï¼‰
public static IHealthCheck HttpHealth(string name, string url, TimeSpan timeout)
    => new FuncHealthCheck(name, async ct =>
{
    using var http = new HttpClient() { Timeout = timeout };
    using var res = await http.GetAsync(url, ct);
    res.EnsureSuccessStatusCode();
});

// 2) ï¼ˆä»»æ„ï¼‰DBã®ç°¡æ˜“ã‚¯ã‚¨ãƒªï¼ˆä¾‹ï¼šSQL Serverï¼‰
// using Microsoft.Data.SqlClient; ãªã©ã‚’å‚ç…§ã«è¿½åŠ ã—ã¦ã‹ã‚‰ï¼š
// public static IHealthCheck SqlHealth(string name, string connStr)
//     => new FuncHealthCheck(name, async ct =>
// {
//     await using var conn = new SqlConnection(connStr);
//     await conn.OpenAsync(ct);
//     await using var cmd = new SqlCommand("SELECT 1", conn);
//     _ = await cmd.ExecuteScalarAsync(ct);
// });

// 3) ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ãªã©
public static IHealthCheck FileHealth(string name, string path)
    => new FuncHealthCheck(name, ct =>
{
    if (!System.IO.File.Exists(path) && !System.IO.Directory.Exists(path))
        throw new InvalidOperationException("not found");
    return Task.CompletedTask;
});
```

---

# 2) ã‚µãƒ¼ãƒãƒ¼ã«çµ„ã¿è¾¼ã‚€ï¼ˆæ—¢å­˜ã® HeartbeatTcpServer ã®æœ€å°å·®åˆ†ï¼‰

* `HeartbeatTcpServer` ã« **`HealthAggregator` ã‚’ä¿æŒ**ã—ã€
* å—ä¿¡ãƒ«ãƒ¼ãƒ—ã§ **`HEALTH?`** ã‚’æ‰±ã„ â†’ **JSON ã§è¿”ç­”**ã€‚

```csharp
// HeartbeatTcpServer ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¿½åŠ 
private readonly HealthAggregator _health = new();

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ or Startå‰ã«ãƒã‚§ãƒƒã‚¯ã‚’ç™»éŒ²ï¼ˆç”¨é€”ã«åˆã‚ã›ã¦ï¼‰
public HeartbeatTcpServer(
    int port,
    TimeSpan? heartbeatInterval = null,
    TimeSpan? heartbeatTimeout = null)
{
    _listener = new TcpListener(IPAddress.Any, port);
    _heartbeatInterval = heartbeatInterval ?? TimeSpan.FromSeconds(10);
    _heartbeatTimeout = heartbeatTimeout ?? TimeSpan.FromSeconds(30);

    // â˜… ã“ã“ã‚’ã‚ãªãŸã®ç’°å¢ƒç”¨ã«èª¿æ•´ã—ã¦ãã ã•ã„
    _health
        .Add(HttpHealth("external-api", "https://example.com/health", TimeSpan.FromSeconds(3)))
        //.Add(SqlHealth("db", "<YourConnectionString>"))
        .Add(FileHealth("local-storage", "C:\\Temp")); // ä¾‹
}
```

å—ä¿¡ãƒ«ãƒ¼ãƒ—ï¼ˆ`ClientSession.ReceiveLoopAsync`ï¼‰ã« **åˆ†å²ã‚’1ã¤è¿½åŠ **ï¼š

```csharp
if (line == "HEALTH?")
{
    // 1ãƒã‚§ãƒƒã‚¯ã‚ãŸã‚Šã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆä¾‹ï¼š2ç§’ï¼‰
    var report = await _server.HealthSnapshotAsync(TimeSpan.FromSeconds(2), ct);
    var json = System.Text.Json.JsonSerializer.Serialize(report);
    await _writer.WriteLineAsync($"HEALTH {json}").ConfigureAwait(false);
    continue;
}
```

`ClientSession` ã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã® `_health` ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã€
`ClientSession` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã« **ã‚µãƒ¼ãƒãƒ¼å‚ç…§ï¼ˆor ãƒ‡ãƒªã‚²ãƒ¼ãƒˆï¼‰** ã‚’æ¸¡ã™ã‹ã€
ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ã‚µãƒ¼ãƒãƒ¼å´ã«è¿½åŠ ï¼š

```csharp
// HeartbeatTcpServer ã«è¿½åŠ 
internal async Task<HealthReport> HealthSnapshotAsync(TimeSpan perCheckTimeout, CancellationToken ct)
    => await _health.RunAsync(perCheckTimeout, ct);
```

ãã—ã¦ `new ClientSession(..., this, ct)` ã®ã‚ˆã†ã«æ¸¡ã—ã€
`ClientSession` å´ã« `private readonly HeartbeatTcpServer _server;` ã‚’æŒãŸã›ã¦ãã ã•ã„ã€‚
ï¼ˆã™ã§ã«é•·ã„ã®ã§éª¨å­ã ã‘ã«ã—ã¾ã—ãŸãŒã€å·®ã—è¾¼ã¿ã¯å®¹æ˜“ã§ã™ã€‚ï¼‰

---

# 3) ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰å•ã„åˆã‚ã›ã‚‹

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã« **`QueryHealthAsync()`** ã‚’è¿½åŠ ã—ã¦ã€
`HEALTH?` ã‚’æŠ•ã’ â†’ 1è¡ŒJSONã‚’å—ã‘å–ã‚‹ã ã‘ã€‚

```csharp
using System.Text.Json;

public sealed class HeartbeatTcpClient : IAsyncDisposable
{
    // ...æ—¢å­˜ã‚³ãƒ¼ãƒ‰...

    public async Task<HealthReport?> QueryHealthAsync(CancellationToken ct = default)
    {
        if (_writer is null || _reader is null) throw new InvalidOperationException("Not connected.");

        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
        await _writer.WriteLineAsync("HEALTH?").ConfigureAwait(false);

        // 1è¡Œå¿œç­”ã‚’å¾…ã¤ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä»˜ã‘ãŸã„å ´åˆã¯ WaitAsync ã‚’ä½µç”¨ï¼‰
        var line = await _reader.ReadLineAsync().WaitAsync(ct).ConfigureAwait(false);
        if (line is null) return null;

        // "HEALTH {json}" å½¢å¼ã‚’æƒ³å®š
        const string prefix = "HEALTH ";
        if (!line.StartsWith(prefix, StringComparison.Ordinal))
            return null;

        var json = line.Substring(prefix.Length);
        return JsonSerializer.Deserialize<HealthReport>(json);
    }
}
```

**ä½¿ã„æ–¹ï¼ˆä¾‹ï¼‰**ï¼š

```csharp
// ã©ã“ã‹ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§
var report = await client.QueryHealthAsync();
if (report is not null)
{
    Console.WriteLine($"overall={report.Overall}");
    foreach (var c in report.Checks)
        Console.WriteLine($" - {c.Name}: {(c.Ok ? "OK" : "FAIL")} ({c.ElapsedMs}ms) {c.Message}");
}
```

---

# 4) ä½•ãŒåˆ†ã‹ã‚‹ã‚ˆã†ã«ãªã‚‹ï¼Ÿ

* ã“ã‚Œã§ **ã€ŒTCPãŒç”Ÿãã¦ã„ã‚‹ã€ï¼‹ã€Œã‚¢ãƒ—ãƒª/ä¾å­˜ã®å¥å…¨æ€§ã€** ã‚’ä¸¡æ–¹åˆ¤å®šå¯èƒ½ã€‚
* ä¾‹ãˆã°ï¼š

  * `overall: FAIL` ã‹ã¤ `db: FAIL "timeout"` â†’ **DBãŒæ­»ã‚“ã§ã‚‹**
  * `overall: OK` â†’ **ã‚µãƒ¼ãƒ“ã‚¹ã¨ã—ã¦å¥å…¨**ï¼ˆå°‘ãªãã¨ã‚‚å®šç¾©ã—ãŸãƒã‚§ãƒƒã‚¯ã¯é€šéï¼‰

---

# 5) é‹ç”¨ã®ãƒ’ãƒ³ãƒˆ

* ãƒã‚§ãƒƒã‚¯ã®ç²’åº¦ã¯ç²—ãï¼ˆ`SELECT 1` / è»½ã„HTTP `/healthz`ï¼‰ã€**çŸ­æ™‚é–“**ã§è¿”ã™
* 1ãƒã‚§ãƒƒã‚¯ã‚ãŸã‚Šã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆä¾‹ï¼š1â€“3ç§’ï¼‰ï¼‹**ç·åˆã®å¤–å½¢SLA** ã‚’è¨­è¨ˆ
* çµæœã‚’ **ãƒ­ã‚°å‡ºåŠ›** ã—ãŸã‚Š **Prometheus/Grafana** ã«è¼‰ã›ã‚‹ã¨ä¾¿åˆ©
* å¿…è¦ãªã‚‰ `overall` ã‚’ã€ŒOK / DEGRADED / FAILã€3å€¤ã«ã—ã¦é‹ç”¨æ„Ÿã«åˆã‚ã›ã‚‹

---

ã“ã‚Œã§ã€ŒPCï¼ˆãƒ—ãƒ­ã‚»ã‚¹ï¼‰ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ã€â†’ã€Œã‚¢ãƒ—ãƒªã‚„ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹ãŒæœ¬å½“ã«å‹•ã„ã¦ã„ã‚‹ã‹ã€ã¾ã§ç¢ºèªã§ãã¾ã™ã€‚
å·®ã—è¾¼ã¿æ™‚ã«è©°ã¾ã‚Šãã†ãªã‚‰ã€ã‚ãªãŸã®æ—¢å­˜ã‚³ãƒ¼ãƒ‰æ–­ç‰‡ã‚’è²¼ã£ã¦ãã‚Œã‚Œã°â€œã“ã“ã«ã“ã®æ•°è¡Œã‚’è¿½åŠ â€ã¾ã§å…·ä½“çš„ã«èª¿æ•´ã—ã¾ã™ã€‚


è‰¯ã„è³ªå•ã§ã™ã€‚
ã“ã“ã¾ã§ã®ä»•çµ„ã¿ï¼ˆTCPï¼‹ã‚¢ãƒ—ãƒªå±¤ã®å¿ƒæ‹ï¼‰ã«åŠ ãˆã¦ã€
**Windows ã‚µãƒ¼ãƒ“ã‚¹ãã®ã‚‚ã®ï¼ˆä¾‹ï¼š`MyService`ï¼‰ãŒå‹•ã„ã¦ã„ã‚‹ã‹ã©ã†ã‹**ã‚’ç›£è¦–ã—ãŸã„ã€ã¨ã„ã†è©±ã§ã™ã­ã€‚

---

## âœ… ç›®çš„

ã€ŒæŒ‡å®šã—ãŸ Windows ã‚µãƒ¼ãƒ“ã‚¹ãŒå®Ÿè¡Œä¸­ (`Running`) ã‹åœæ­¢ (`Stopped`) ã‹ã‚’ã€
ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã‹ã‚‰èª¿ã¹ãŸã„ãƒ»ç›£è¦–ã—ãŸã„ã€

---

## ğŸ’¡ æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæ–¹æ³•ï¼š`System.ServiceProcess.ServiceController`

.NET æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

```csharp
using System;
using System.ServiceProcess;

public static class ServiceMonitor
{
    public static bool IsServiceRunning(string serviceName, string machineName = ".")
    {
        try
        {
            using var sc = new ServiceController(serviceName, machineName);
            return sc.Status == ServiceControllerStatus.Running;
        }
        catch (InvalidOperationException)
        {
            // ã‚µãƒ¼ãƒ“ã‚¹ãŒå­˜åœ¨ã—ãªã„
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ServiceMonitor] {ex.Message}");
            return false;
        }
    }
}
```

### ä½¿ç”¨ä¾‹

```csharp
bool alive = ServiceMonitor.IsServiceRunning("Spooler"); // å°åˆ·ã‚¹ãƒ—ãƒ¼ãƒ©ãƒ¼
Console.WriteLine(alive ? "ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•ä¸­" : "ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢ä¸­");
```

* `machineName` ã« `"."`ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ã¾ãŸã¯ãƒªãƒ¢ãƒ¼ãƒˆãƒ›ã‚¹ãƒˆåã‚’æŒ‡å®šå¯ã€‚
* ãƒªãƒ¢ãƒ¼ãƒˆç›£è¦–ã«ã¯ãã®ãƒ›ã‚¹ãƒˆã§ç®¡ç†è€…æ¨©é™ï¼‹RPCè¨±å¯ãŒå¿…è¦ã€‚

---

## ğŸš€ ã‚µãƒ¼ãƒ“ã‚¹ç›£è¦–ã‚’ã€Œãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã€ã«çµ±åˆã™ã‚‹ä¾‹

å…ˆã»ã©ã® `HealthAggregator` ã«çµ„ã¿è¾¼ã‚ã¾ã™ï¼š

```csharp
public static IHealthCheck WindowsServiceHealth(string serviceName, string? machineName = null)
    => new FuncHealthCheck($"svc:{serviceName}", async ct =>
{
    await Task.Yield(); // asyncç½²åã®ãŸã‚
    if (!ServiceMonitor.IsServiceRunning(serviceName, machineName ?? "."))
        throw new InvalidOperationException("Service not running");
});
```

### ç™»éŒ²ä¾‹

```csharp
_health
    .Add(WindowsServiceHealth("Spooler"))
    .Add(WindowsServiceHealth("MyAppService"));
```

â†’ `HEALTH?` ã‚³ãƒãƒ³ãƒ‰ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªçµæœãŒè¿”ã‚‹ï¼š

```json
{
  "overall": "FAIL",
  "checks": [
    { "name": "svc:Spooler", "ok": true, "elapsedMs": 2 },
    { "name": "svc:MyAppService", "ok": false, "elapsedMs": 1, "message": "Service not running" }
  ]
}
```

---

## âš™ï¸ å¿œç”¨

| è¦ä»¶                  | æ–¹æ³•                                                                  |
| ------------------- | ------------------------------------------------------------------- |
| **ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã®ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹** | `new ServiceController(name, "server01")` ã§RPCæ¥ç¶šï¼ˆãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã§RPCè¨±å¯ãŒå¿…è¦ï¼‰ |
| **ç®¡ç†è€…æ¨©é™ä¸è¦ã§ç¢ºèªã—ãŸã„**   | ã‚µãƒ¼ãƒ“ã‚¹è‡ªä½“ã« `/health` API ã‚’ä½œã‚Šã€HTTPçµŒç”±ã§ç›£è¦–                                 |
| **åœæ­¢ã—ã¦ã„ãŸã‚‰è‡ªå‹•å†èµ·å‹•ã—ãŸã„** | `sc.Start()` ã‚’å‘¼ã¶ or PowerShell ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§åˆ¶å¾¡ï¼ˆè¦ç®¡ç†è€…ï¼‰                       |
| **è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹ã®ä¸€æ‹¬ç›£è¦–**     | `GetServices()` ã§åˆ—æŒ™ã€LINQã§çŠ¶æ…‹ã‚’æŠ½å‡ºã—ã¦ `HealthAggregator` ã«ã¾ã¨ã‚ã‚‹           |

---

## ğŸ§© ã¾ã¨ã‚

| æ¤œå‡ºãƒ¬ãƒ™ãƒ«      | ä»•çµ„ã¿                               | æ¤œå‡ºå¯¾è±¡                  |
| ---------- | --------------------------------- | --------------------- |
| OSï¼ãƒ—ãƒ­ã‚»ã‚¹    | TCPï¼KeepAliveï¼PING                | ãƒ—ãƒ­ã‚»ã‚¹ãƒ»æ¥ç¶šè‡ªä½“ãŒç”Ÿãã¦ã„ã‚‹ã‹      |
| ã‚¢ãƒ—ãƒªï¼ã‚µãƒ¼ãƒ“ã‚¹å†…éƒ¨ | `HEALTH?` æ‹¡å¼µï¼ˆHTTP, DB, File etc.ï¼‰ | æ¥­å‹™å‡¦ç†ã®å¥å…¨æ€§              |
| OSã‚µãƒ¼ãƒ“ã‚¹     | `ServiceController`               | ç‰¹å®šã® Windows ã‚µãƒ¼ãƒ“ã‚¹ãŒèµ·å‹•ä¸­ã‹ |

---

å¿…è¦ãªã‚‰ã€ã“ã® Windows ã‚µãƒ¼ãƒ“ã‚¹ç›£è¦–ã‚’**å®šæœŸçš„ã«ã‚µãƒ¼ãƒãƒ¼å´ã§è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã—ã¦ã€çµæœã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã« push é€šçŸ¥**ã™ã‚‹æ‹¡å¼µï¼ˆä¾‹ãˆã° `"ALERT svc:MyService stopped"`ï¼‰ã‚‚ä½œã‚Œã¾ã™ã€‚
ãã®æ–¹å‘ã«ã‚‚é€²ã‚ã¾ã™ã‹ï¼Ÿ

ã¨ã¦ã‚‚ã„ã„è³ªå•ã§ã™ã€‚
`ServiceControllerStatus`ï¼ˆ`System.ServiceProcess` åå‰ç©ºé–“ï¼‰ã«ã¯ã€
å®Ÿã¯ **2ã¤ï¼ˆRunning / Stoppedï¼‰ã ã‘ã§ãªãã€å…¨éƒ¨ã§ 6ç¨®é¡** ã®çŠ¶æ…‹ãŒã‚ã‚Šã¾ã™ã€‚

---

## ğŸ§© ä¸€è¦§ï¼š`ServiceControllerStatus` ã®å…¨åˆ—æŒ™å€¤

| å€¤                   | æ„å‘³          | è£œè¶³                           |
| ------------------- | ----------- | ---------------------------- |
| **Stopped**         | ã‚µãƒ¼ãƒ“ã‚¹ãŒåœæ­¢ã—ã¦ã„ã‚‹ | å®Œå…¨ã«åœæ­¢æ¸ˆã¿ã€‚`Start()` å¯èƒ½ãªçŠ¶æ…‹ã€‚     |
| **StartPending**    | ã‚µãƒ¼ãƒ“ã‚¹ã‚’é–‹å§‹ä¸­    | ã¾ã èµ·å‹•å‡¦ç†ãŒå®Œäº†ã—ã¦ã„ãªã„ï¼ˆåˆæœŸåŒ–ä¸­ãªã©ï¼‰ã€‚      |
| **StopPending**     | ã‚µãƒ¼ãƒ“ã‚¹ã‚’åœæ­¢ä¸­    | çµ‚äº†å‡¦ç†ã®é€”ä¸­ã€‚                     |
| **Running**         | ã‚µãƒ¼ãƒ“ã‚¹ãŒå®Ÿè¡Œä¸­    | é€šå¸¸ã®ã€Œç¨¼åƒä¸­ã€çŠ¶æ…‹ã€‚                  |
| **ContinuePending** | ä¸€æ™‚åœæ­¢ã‹ã‚‰å†é–‹ä¸­   | `Continue()` å‘¼ã³å‡ºã—å¾Œã€å†é–‹å‡¦ç†ä¸­ã€‚    |
| **PausePending**    | ä¸€æ™‚åœæ­¢å‡¦ç†ä¸­     | `Pause()` å‘¼ã³å‡ºã—å¾Œã€ã¾ã åœæ­¢å®Œäº†ã—ã¦ã„ãªã„ã€‚ |
| **Paused**          | ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸€æ™‚åœæ­¢ä¸­  | ä¸€æ™‚åœæ­¢å®Œäº†å¾Œã®å®‰å®šçŠ¶æ…‹ã€‚                |

---

## ğŸ’¡ å®Ÿéš›ã®ä½¿ã„æ–¹ã®ç›®å®‰

```csharp
using System.ServiceProcess;

using var sc = new ServiceController("Spooler");

switch (sc.Status)
{
    case ServiceControllerStatus.Running:
        Console.WriteLine("å®Ÿè¡Œä¸­");
        break;
    case ServiceControllerStatus.Stopped:
        Console.WriteLine("åœæ­¢ä¸­");
        break;
    case ServiceControllerStatus.Paused:
        Console.WriteLine("ä¸€æ™‚åœæ­¢ä¸­");
        break;
    case ServiceControllerStatus.StartPending:
    case ServiceControllerStatus.ContinuePending:
        Console.WriteLine("èµ·å‹•å‡¦ç†ä¸­...");
        break;
    case ServiceControllerStatus.StopPending:
    case ServiceControllerStatus.PausePending:
        Console.WriteLine("åœæ­¢å‡¦ç†ä¸­...");
        break;
}
```

---

## âœ… ã€Œç”Ÿãã¦ã„ã‚‹ã€ã¨åˆ¤å®šã™ã‚‹åŸºæº–

å¤šãã®å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ç°¡ç•¥åŒ–ã—ã¦æ‰±ã„ã¾ã™ï¼š

```csharp
bool IsServiceAlive(ServiceController sc)
{
    return sc.Status == ServiceControllerStatus.Running ||
           sc.Status == ServiceControllerStatus.StartPending ||
           sc.Status == ServiceControllerStatus.ContinuePending;
}
```

ã¤ã¾ã‚Šã€ã€Œèµ·å‹•ä¸­ã€ã¾ãŸã¯ã€Œå†é–‹ä¸­ã€ã‚‚ã€Œç”Ÿãã¦ã„ã‚‹ã€ã¨ã¿ãªã—ã¾ã™ã€‚

---

## âš™ï¸ çŠ¶æ…‹æ›´æ–°ã®æ³¨æ„ç‚¹

* `sc.Status` ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€
  **æœ€æ–°çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹ã«ã¯ `sc.Refresh()` ãŒå¿…è¦** ã§ã™ã€‚
  ä¾‹ï¼š

  ```csharp
  sc.Refresh();
  Console.WriteLine(sc.Status);
  ```

* çŠ¶æ…‹é·ç§»ã‚’å¾…ã¡ãŸã„å ´åˆã¯ `WaitForStatus(...)` ãŒä¾¿åˆ©ã§ã™ï¼š

  ```csharp
  sc.Start();
  sc.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(10));
  ```

---

## ğŸ§­ ã¾ã¨ã‚

| çŠ¶æ…‹                                        | èª¬æ˜         | ç”Ÿãã¦ã‚‹æ‰±ã„ï¼Ÿ  |
| ----------------------------------------- | ---------- | -------- |
| `Running`                                 | å®Ÿè¡Œä¸­        | âœ…        |
| `StartPending` / `ContinuePending`        | èµ·å‹•ï¼å†é–‹ä¸­     | âœ…ï¼ˆå‹•ä½œæº–å‚™ä¸­ï¼‰ |
| `Stopped`                                 | å®Œå…¨åœæ­¢       | âŒ        |
| `StopPending` / `PausePending` / `Paused` | åœæ­¢ã¾ãŸã¯ä¸€æ™‚åœæ­¢ä¸­ | âŒ        |

---

ã”å¸Œæœ›ãŒã‚ã‚Œã°ã€
ğŸ’¡ã€Œç‰¹å®šã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ã‚’ç›£è¦–ã—ã€åœæ­¢æ¤œçŸ¥ã§å†èµ·å‹• or é€šçŸ¥ã™ã‚‹ã€
ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆã‚¿ã‚¤ãƒãƒ¼å¸¸é§å‹ï¼‰ã‚‚ç¤ºã›ã¾ã™ã€‚å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

äº†è§£ï¼
**ã€Œç‰¹å®šã® Windows ã‚µãƒ¼ãƒ“ã‚¹ã‚’å¸¸æ™‚ç›£è¦–ã—ã€æ­¢ã¾ã£ã¦ãŸã‚‰è‡ªå‹•å†èµ·å‹•ï¼ˆï¼‹é€šçŸ¥ï¼‰ã€**ã™ã‚‹æœ€å°ï½å®Ÿç”¨ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚
ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å¸¸é§ã§å‹•ã‹ã›ã¾ã™ï¼ˆå¿…è¦ãªã‚‰ Windows ã‚µãƒ¼ãƒ“ã‚¹åŒ–ã‚‚OKï¼‰ã€‚

---

# âœ… ã§ãã‚‹ã“ã¨

* æŒ‡å®šã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ã‚’ä¸€å®šé–“éš”ã§ç›£è¦–ï¼ˆ`Running` ä»¥å¤–ã‚’æ¤œçŸ¥ï¼‰
* `Stopped` / `Paused` ãªã‚‰ **è‡ªå‹•å¾©æ—§**ï¼ˆ`Start()` / `Continue()`ï¼‰
* å¾©æ—§ã«å¤±æ•—ã—ãŸã‚‰ **Windows ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã«è¨˜éŒ²**ï¼ˆæ¨©é™ãªã„å ´åˆã¯æ¨™æº–å‡ºåŠ›ã¸ï¼‰
* å®‰å…¨ãªå¾…æ©Ÿï¼ˆ`WaitForStatus`ï¼‰ã¨ãƒªãƒˆãƒ©ã‚¤å›æ•°ãƒ»é–“éš”ã®èª¿æ•´

---

# ğŸ§© ç›£è¦–ãƒ»è‡ªå‹•å¾©æ—§ã‚³ãƒ¼ãƒ‰ï¼ˆ.NET 6+ / C# 10 ç›®å®‰ï¼‰

```csharp
using System;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;
using System.Threading.Tasks;

public sealed class ServiceWatchdog
{
    private readonly string _serviceName;
    private readonly string _machineName;
    private readonly TimeSpan _checkInterval;
    private readonly int _maxRestartRetries;
    private readonly TimeSpan _statusWait;      // Start/Continue å¾Œã« Running ã‚’å¾…ã¤æ™‚é–“
    private readonly bool _autoRecover;         // åœæ­¢/ä¸€æ™‚åœæ­¢ã‚’è‡ªå‹•å¾©æ—§ã™ã‚‹ã‹
    private readonly string _eventSource;       // ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã®ã‚½ãƒ¼ã‚¹å

    public ServiceWatchdog(
        string serviceName,
        string machineName = ".",
        TimeSpan? checkInterval = null,
        int maxRestartRetries = 3,
        TimeSpan? statusWait = null,
        bool autoRecover = true,
        string? eventSource = null)
    {
        _serviceName = serviceName;
        _machineName = machineName;
        _checkInterval = checkInterval ?? TimeSpan.FromSeconds(10);
        _maxRestartRetries = Math.Max(0, maxRestartRetries);
        _statusWait = statusWait ?? TimeSpan.FromSeconds(15);
        _autoRecover = autoRecover;
        _eventSource = eventSource ?? $"SvcWatchdog-{serviceName}";
        TryEnsureEventSource();
    }

    public async Task RunAsync(CancellationToken ct)
    {
        LogInfo($"Watch start: service='{_serviceName}', machine='{_machineName}'");

        while (!ct.IsCancellationRequested)
        {
            try
            {
                await CheckOnceAsync(ct).ConfigureAwait(false);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                LogError($"Unexpected error: {ex.Message}");
            }

            try { await Task.Delay(_checkInterval, ct).ConfigureAwait(false); }
            catch (OperationCanceledException) { break; }
        }

        LogInfo("Watch stopped.");
    }

    private async Task CheckOnceAsync(CancellationToken ct)
    {
        using var sc = new ServiceController(_serviceName, _machineName);
        sc.Refresh();

        var st = sc.Status;
        // èµ·å‹•å‡¦ç†ä¸­ï¼åœæ­¢å‡¦ç†ä¸­ã¯æ¬¡å‘¨æœŸã¸
        if (st is ServiceControllerStatus.StartPending or ServiceControllerStatus.StopPending
                or ServiceControllerStatus.PausePending or ServiceControllerStatus.ContinuePending)
        {
            LogDebug($"Pending... Status={st}");
            return;
        }

        if (st == ServiceControllerStatus.Running)
        {
            LogDebug("Running");
            return;
        }

        // Paused / Stopped ãªã© â†’ è‡ªå‹•å¾©æ—§ã™ã‚‹
        if (!_autoRecover)
        {
            LogWarn($"Not running: Status={st}");
            return;
        }

        for (int attempt = 1; attempt <= _maxRestartRetries; attempt++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                sc.Refresh();
                st = sc.Status;

                if (st == ServiceControllerStatus.Paused)
                {
                    LogWarn($"Service paused. Trying Continue() (attempt {attempt}/{_maxRestartRetries})");
                    sc.Continue();
                    sc.WaitForStatus(ServiceControllerStatus.Running, _statusWait);
                }
                else if (st != ServiceControllerStatus.Running)
                {
                    LogWarn($"Service not running (Status={st}). Trying Start() (attempt {attempt}/{_maxRestartRetries})");
                    sc.Start();
                    sc.WaitForStatus(ServiceControllerStatus.Running, _statusWait);
                }

                sc.Refresh();
                if (sc.Status == ServiceControllerStatus.Running)
                {
                    LogInfo("Recovery success: Running");
                    return;
                }

                LogWarn($"Recovery attempt finished but status={sc.Status}");
            }
            catch (InvalidOperationException ex)
            {
                LogError($"Service control error: {ex.Message}");
            }
            catch (System.ComponentModel.Win32Exception ex)
            {
                LogError($"Insufficient privileges or control denied: {ex.Message}");
            }
            catch (System.ServiceProcess.TimeoutException)
            {
                LogWarn($"WaitForStatus timeout (>{_statusWait.TotalSeconds}s)");
            }
            catch (Exception ex)
            {
                LogError($"Recovery attempt error: {ex.Message}");
            }

            // æ¬¡ã®è©¦è¡Œã¾ã§å¾…æ©Ÿï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®ç°¡æ˜“ç‰ˆï¼‰
            try { await Task.Delay(TimeSpan.FromSeconds(5 * attempt), ct).ConfigureAwait(false); }
            catch (OperationCanceledException) { return; }
        }

        LogError($"Recovery FAILED after {_maxRestartRetries} attempts.");
    }

    #region Logging (EventLog â†’ Console ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
    private void TryEnsureEventSource()
    {
        try
        {
            const string logName = "Application";
            if (!EventLog.SourceExists(_eventSource))
                EventLog.CreateEventSource(_eventSource, logName);
        }
        catch
        {
            // æ¨©é™ãŒãªã„å ´åˆã¯ä½œæˆã§ããªã„ â†’ Console ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        }
    }

    private void WriteEvent(string msg, EventLogEntryType type)
    {
        try { EventLog.WriteEntry(_eventSource, msg, type); }
        catch { Console.WriteLine($"{DateTime.Now:O} [{type}] {msg}"); }
    }

    private void LogInfo(string m) => WriteEvent(m, EventLogEntryType.Information);
    private void LogWarn(string m) => WriteEvent(m, EventLogEntryType.Warning);
    private void LogError(string m) => WriteEvent(m, EventLogEntryType.Error);
    private void LogDebug(string m)
    {
#if DEBUG
        WriteEvent(m, EventLogEntryType.Information);
#endif
    }
    #endregion
}
```

## èµ·å‹•ã‚³ãƒ¼ãƒ‰ï¼ˆCtrl+C ã§çµ‚äº†ï¼‰

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) => { e.Cancel = true; cts.Cancel(); };

        // â˜…ç›£è¦–ã—ãŸã„ã‚µãƒ¼ãƒ“ã‚¹åã«ç½®ãæ›ãˆ
        var watchdog = new ServiceWatchdog(
            serviceName: "Spooler",        // ä¾‹: å°åˆ·ã‚¹ãƒ—ãƒ¼ãƒ©ãƒ¼
            machineName: ".",              // ã¾ãŸã¯ "SERVER01"
            checkInterval: TimeSpan.FromSeconds(10),
            maxRestartRetries: 3,
            statusWait: TimeSpan.FromSeconds(15),
            autoRecover: true
        );

        await watchdog.RunAsync(cts.Token);
    }
}
```

---

## ğŸ” æ¨©é™ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ³¨æ„

* **ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹ã®å–å¾—**ã¯ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã‚‚è¦‹ãˆã‚‹ã“ã¨ãŒå¤šã„ã§ã™ãŒã€
  **`Start/Stop/Continue` ãªã©ã®åˆ¶å¾¡ã¯ç®¡ç†è€…æ¨©é™ãŒå¿…è¦**ã§ã™ã€‚
* **ãƒªãƒ¢ãƒ¼ãƒˆç›£è¦–**ï¼ˆ`machineName` ã«ãƒ›ã‚¹ãƒˆåæŒ‡å®šï¼‰ã¯ã€
  å¯¾è±¡å´ã® **ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ï¼ˆRPC/ã‚µãƒ¼ãƒ“ã‚¹åˆ¶å¾¡ãƒãƒãƒ¼ã‚¸ãƒ£ï¼‰** è¨±å¯ã¨è³‡æ ¼æƒ…å ±ãŒå¿…è¦ã§ã™ã€‚

---

## ğŸ§ª å‹•ä½œç¢ºèªã®ã‚³ãƒ„

* ç›£è¦–å¯¾è±¡ã‚’ `Spooler` ã«ã—ã¦ã€`services.msc` ã‹ã‚‰ä¸€æ™‚åœæ­¢/åœæ­¢ã—ã¦ãƒ­ã‚°å‡ºåŠ›ã‚„è‡ªå‹•å¾©æ—§ã‚’ç¢ºèªã€‚
* æœ¬ç•ªå°å…¥æ™‚ã¯ **å°‚ç”¨ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ**ï¼‹**æœ€å°æ¨©é™**ã§é‹ç”¨ã‚’ã€‚

---

## ğŸ”§ ã‚‚ã£ã¨ã‚„ã‚‹ãªã‚‰

* é€£ç¶šå¤±æ•—å›æ•°ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹åŒ–ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°IDã‚„Prometheusãªã©ï¼‰
* å¾©æ—§ã«å¤±æ•—ã—ãŸã‚‰ **ãƒ¡ãƒ¼ãƒ«/Slack/Webhook** é€šçŸ¥
* ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆDB/HTTPï¼‰ãƒã‚§ãƒƒã‚¯ã¨ **ã¾ã¨ã‚ã¦ overall åˆ¤å®š**ï¼ˆå‰å›ã¾ã§ã®ãƒ˜ãƒ«ã‚¹æ‹¡å¼µã¨çµ±åˆï¼‰

å¿…è¦ãªã‚‰ **Windows ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆ`WorkerService`ï¼‰åŒ–ãƒ†ãƒ³ãƒ—ãƒ¬** ã‚‚ç”¨æ„ã—ã¾ã™ã€‚
